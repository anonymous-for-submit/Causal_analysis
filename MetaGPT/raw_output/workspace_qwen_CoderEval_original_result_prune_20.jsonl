{"file_name": "CoderEval_49", "requirements": "", "code": "## main.py\nfrom datetime import timedelta\nfrom typing import Optional\n\ndef parse_frequency(frequency: Optional[str]) -> Optional[timedelta]:\n    \"\"\"\n    Given a frequency string with a number and a unit of time, return a corresponding\n    datetime.timedelta instance.\n    If the frequency is None or 'always', return None.\n    Raise ValueError if the given frequency cannot be parsed.\n    For instance, given '3 days', return datetime.timedelta(days=3)\n    \n    @param frequency :  A frequency string 'number timeunit'\n    \n    @return Optional[timedelta], the corresponding datetime\n    \"\"\"\n    if frequency is None or frequency.lower() == 'always':\n        return None\n\n    try:\n        number, unit = frequency.split()\n        number = int(number)\n\n        if unit == 'days':\n            return timedelta(days=number)\n        elif unit == 'hours':\n            return timedelta(hours=number)\n        elif unit == 'minutes':\n            return timedelta(minutes=number)\n        elif unit == 'seconds':\n            return timedelta(seconds=number)\n        else:\n            raise ValueError(f\"Unsupported time unit: {unit}\")\n    except (ValueError, AttributeError):\n        raise ValueError(f\"Invalid frequency string: {frequency}\")\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def parse_frequency(frequency):\n\t\"\"\"\n\tGiven a frequency string with a number and a unit of time, return a corresponding\n     datetime.timedelta instance.\n     If the frequency is None or 'always', return None.\n     Raise ValueError if the given frequency cannot be parsed.\n     For instance, given '3 timeunit', return datetime.timedelta(timeunit=3)\n\n     @param frequency :  A frequency string 'number timeunit'\n\n    @return str, the corresponding datetime\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def parse_frequency(frequency: typing.Optional[str]) -> typing.Optional[datetime.timedelta]:\n    \"\"\"\n    Given a frequency string with a number and a unit of time, return a corresponding\n    datetime.timedelta instance.\n    If the frequency is None or 'always', return None.\n    Raise ValueError if the given frequency cannot be parsed.\n    For instance, given '3 days', return datetime.timedelta(days=3)\n    \n    @param frequency :  A frequency string 'number timeunit'\n    \n   @return str, the corresponding datetime\n    \"\"\"", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_56", "requirements": "", "code": "## main.py\n\nimport os\nimport re\n\ndef _resolve_string(matcher: re.Match) -> str:\n    \"\"\"Resolves the matched group from a regex match object to an environment variable or a default value.\n\n    Args:\n        matcher (re.Match): The match object containing the captured groups.\n\n    Returns:\n        str: The resolved string from the environment variable or the default value.\n\n    Raises:\n        KeyError: If the environment variable does not exist and no default value is provided.\n    \"\"\"\n    env_var_name = matcher.group(1)\n    default_value = matcher.group(2)\n\n    # Check if the environment variable exists\n    if env_var_name in os.environ:\n        return os.environ[env_var_name]\n    elif default_value is not None:\n        return default_value\n    else:\n        raise KeyError(f\"Environment variable {env_var_name} not found and no default value provided.\")\n\n# Example usage\nif __name__ == \"__main__\":\n    pattern = r\"\\$(\\w+)(?:\\(([^)]*)\\))?\"\n    test_string = \"$MY_VAR(default_value)\"\n    match = re.search(pattern, test_string)\n    if match:\n        print(_resolve_string(match))\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def _resolve_string(matcher):\n    \"\"\"Get the value from environment given a matcher containing a name and an optional default value in its group dict.\n    If the variable is not defined in environment and no default value is provided, an Error is raised.\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `_resolve_string` takes a single argument `matcher`, which is a `re.Match` object. It returns a string representing the value of the environment variable or the default value if specified. If the environment variable does not exist and no default value is provided, it raises an exception.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_44", "requirements": "", "code": "## main.py\n\ndef unquote(name: str) -> str:\n    \"\"\"Unquotes a string by removing leading and trailing quotes.\n\n    Args:\n        name (str): The string to unquote.\n\n    Returns:\n        str: The unquoted string.\n    \"\"\"\n    if len(name) < 2:\n        return name\n    if name[0] == '\"' and name[-1] == '\"':\n        return name[1:-1]\n    if name[0] == \"'\" and name[-1] == \"'\":\n        return name[1:-1]\n    return name\n\n# Example usage\nif __name__ == \"__main__\":\n    print(unquote('\"Hello\"'))  # Output: Hello\n    print(unquote(\"'World'\"))  # Output: World\n    print(unquote('Python'))   # Output: Python\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def unquote(name):\n    \\\\\"\\\\\"Remove quote from the given name with regular expression.\n    Args:\n        name: input name\n    Returns:\n        name after removal\n    \\\\\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def unquote(name: str) -> str:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_21", "requirements": "", "code": "## main.py\n\ndef base_config(user: str, etcd_host: str = 'localhost', etcd_port: int = 2379) -> dict:\n    \"\"\"\n    Generates a base configuration dictionary for a system based on provided parameters.\n\n    Args:\n        user (str): The username for authentication.\n        etcd_host (str): The host address for the etcd server. Defaults to 'localhost'.\n        etcd_port (int): The port number for the etcd server. Defaults to 2379.\n\n    Returns:\n        dict: A dictionary containing configuration settings for various components.\n    \"\"\"\n    config = {\n        'tls': 'disabled',\n        'authentication': 'enabled',\n        'authorization': 'enabled',\n        'etcd': f'{etcd_host}:{etcd_port}',\n        'docs': 'https://example.com/docs',\n        'log': 'info'\n    }\n    return config\n\n\n# Example usage\nif __name__ == \"__main__\":\n    print(base_config('admin'))\n    print(base_config('user', etcd_host='192.168.1.100', etcd_port=2380))\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def base_config(user, etcd_host=\"localhost\", etcd_port=2379):\n\t\"\n\tCreates a configuration with some simple parameters, the key parameters contains \"tls\", \"authentication\", \"authorization\", \"etcd\", \"docs\", and \"log\".\n\t\"\n\t", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `base_config` takes in three parameters: `user` (str), `etcd_host` (str) with default value 'localhost', and `etcd_port` (int) with default value 2379. It returns a dictionary with keys 'tls', 'authentication', 'authorization', 'etcd', 'docs', and 'log'. Each key maps to a string value indicating the status or configuration related to that parameter.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_23", "requirements": "", "code": "## main.py\n\ndef plus_or_dot(pieces: list[str]) -> str:\n    \"\"\"Determine whether to return '+' or '.' based on the number of pieces provided.\n\n    Args:\n        pieces (list[str]): A list of strings representing pieces.\n\n    Returns:\n        str: Either '+' or '.', depending on the number of pieces.\n    \"\"\"\n    if len(pieces) > 1:\n        return '+'\n    else:\n        return '.'\n\n# Example usage\nif __name__ == \"__main__\":\n    print(plus_or_dot([\"apple\"]))  # Should print '.'\n    print(plus_or_dot([\"apple\", \"banana\"]))  # Should print '+'\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def plus_or_dot(pieces):\n    \"\"\"\n    Return \".\" If the closest tag of the pieces contains \"+\", otherwise, return \"+\".\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `plus_or_dot` takes a single argument `pieces`, which is a list of strings. It returns a string, either `.` or `+`.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_6", "requirements": "", "code": "## main.py\n\nfrom typing import Final\n\nIMPLEMENTATION_CLASS_SUFFIX: Final[str] = 'Py'\nFALLBACK_CLASS_SUFFIX: Final[str] = 'Fallback'\n\ndef get_target_class() -> str:\n    \"\"\"Return the implementation in use without the 'Py' or 'Fallback' suffix.\"\"\"\n    if some_condition():\n        return 'Implementation' + IMPLEMENTATION_CLASS_SUFFIX\n    else:\n        return 'Implementation' + FALLBACK_CLASS_SUFFIX\n\ndef some_condition() -> bool:\n    \"\"\"Determine the condition for selecting the implementation class.\"\"\"\n    # Replace with actual condition checking logic\n    # Example: return True if some condition is met, False otherwise\n    # Here's an example of how you might implement this:\n    # For demonstration purposes, let's assume we have a condition based on an environment variable\n    import os\n    return os.getenv('USE_IMPLEMENTATION', 'false').lower() == 'true'\n\nif __name__ == \"__main__\":\n    target_class = get_target_class()\n    print(f\"The target class is: {target_class}\")\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def _getTargetClass(self):\n    \"\"\"Define this to return the implementation in use,\n    without the 'Py' or 'Fallback' suffix.\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def get_target_class() -> str:\n    \"\"\"Return the implementation in use without the 'Py' or 'Fallback' suffix.\"\"\"\n    return 'Implementation'", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_43", "requirements": "", "code": "## main.py\n\nimport re\n\ndef regex_dict(item: dict) -> dict:\n    \"\"\"Converts dictionary keys from wildcard patterns to regular expressions.\n\n    Args:\n        item (dict): A dictionary where keys are strings representing filenames with wildcards.\n\n    Returns:\n        dict: A new dictionary with keys converted to regular expressions.\n    \"\"\"\n    result = {}\n    for key, value in item.items():\n        # Convert wildcard pattern to regular expression\n        regex_key = re.escape(key).replace(r'\\*', r'.*').replace(r'\\?', '.')\n        \n        # Append $ at the end of the regex key\n        regex_key += '$'\n        \n        result[regex_key] = value\n    \n    return result\n\n\n# Example usage\nif __name__ == \"__main__\":\n    sample_dict = {\n        \"*.cpp\": \"C++ files\",\n        \"main.py\": \"Python script\",\n        \"??.txt\": \"Text files with two-character names\"\n    }\n    print(regex_dict(sample_dict))\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def regex_dict(item):\n\t\"\n\tConvert *.cpp keys to regex keys.\nGiven a dict where the keys are all filenames with wildcards,\nconvert only the keys into equivalent regexes and leave the values intact.\n\nArgs:\n    item: dict to convert\nReturns:\n    dict with keys converted to regexes\n\t\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `regex_dict` takes a single parameter `item`, which is a dictionary. The keys of this dictionary are strings representing filenames with wildcards (e.g., `*.cpp`). The function returns a new dictionary with the keys converted to regular expressions (e.g., `.*\\.cpp$`). The values in the dictionary remain unchanged.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_61", "requirements": "", "code": "from typing import List, Dict\n\ndef from_raw_values(values: List[str]) -> List[Dict[str, str]]:\n    \"\"\"\n    Takes a list of strings representing raw bookmark values and returns a list of dictionaries \n    where each dictionary represents a bookmark with keys such as 'title', 'url', etc.\n    \n    Args:\n        values (List[str]): A list of strings representing raw bookmark values.\n        \n    Returns:\n        List[Dict[str, str]]: A list of dictionaries representing bookmarks.\n    \"\"\"\n    bookmarks = []\n    for value in values:\n        # Assuming each string in the list is a comma-separated value representing a bookmark\n        # Example: \"Google,https://www.google.com\"\n        parts = value.split(',')\n        if len(parts) != 2:\n            raise ValueError(f\"Invalid bookmark value: {value}\")\n        \n        title, url = parts\n        bookmark = {\n            'title': title.strip(),\n            'url': url.strip()\n        }\n        bookmarks.append(bookmark)\n    \n    return bookmarks\n\n# Example usage\nif __name__ == \"__main__\":\n    raw_bookmarks = [\n        \"Google,https://www.google.com\",\n        \"GitHub,https://github.com\",\n        \"Stack Overflow,https://stackoverflow.com\"\n    ]\n    bookmarks = from_raw_values(raw_bookmarks)\n    print(bookmarks)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def from_raw_values(cls, values):\n    \"\"\"Create a Bookmarks object from a list of raw bookmark string values.\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `from_raw_values(values: List[str]) -> List[Dict[str, str]]` takes a list of strings representing raw bookmark values and returns a list of dictionaries where each dictionary represents a bookmark with keys such as 'title', 'url', etc.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_11", "requirements": "", "code": "## main.py\n\nclass ExampleClass:\n    def __init__(self):\n        self.fill = True\n        self.request = True\n\ndef is_fill_request_el(obj: ExampleClass) -> bool:\n    \"\"\"\n    Check whether the obj class has the fill and request attributes.\n\n    :param obj: The object to check\n    :return: True if the object has both fill and request attributes, False otherwise\n    \"\"\"\n    return hasattr(obj, 'fill') and hasattr(obj, 'request')\n\n# Example usage\nif __name__ == \"__main__\":\n    example_obj = ExampleClass()\n    print(is_fill_request_el(example_obj))  # Should print True\n\n    # Test with an object without the required attributes\n    class AnotherClass:\n        pass\n\n    another_obj = AnotherClass()\n    print(is_fill_request_el(another_obj))  # Should print False\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def is_fill_request_el(obj):\n    \"\"\"Check whether the obj class has the fill and request attributes.\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def is_fill_request_el(obj) -> bool:\n    Check whether the obj class has the fill and request attributes.\n\n    :param obj: The object to check\n    :return: True if the object has both fill and request attributes, False otherwise", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_53", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_16", "requirements": "", "code": "## main.py\nimport os\nfrom typing import List\n\ndef files_list(path: str) -> List[str]:\n    \"\"\"Returns a list of file names from the specified directory path.\n\n    Args:\n        path (str): The directory path to list files from.\n\n    Returns:\n        List[str]: A list of file names within the specified directory or an error message if an issue occurs.\n    \"\"\"\n    try:\n        # Ensure the path exists and is a directory\n        if not os.path.isdir(path):\n            raise ValueError(f\"The provided path '{path}' is not a valid directory.\")\n        \n        # Get all entries in the directory\n        entries = os.listdir(path)\n        \n        # Filter out directories and return only files\n        files = [entry for entry in entries if os.path.isfile(os.path.join(path, entry))]\n        \n        return files\n    \n    except ValueError as ve:\n        return [str(ve)]\n    except Exception as e:\n        return [f\"An unexpected error occurred: {e}\"]\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def files_list(path):\n    \"\"\"\n    Return the files in given path.\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `files_list` takes a single argument `path` (str) and returns a list of file names (List[str]).", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_36", "requirements": null, "code": null, "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def int_to_string(number: int, alphabet: List[str], padding: Optional[int] = None) -> str:\n    \"\"\" Convert a number to a string, using the given alphabet.\n    The number represents a short uuid.\n    The output has the most significant digit first.\n    @param number: Int value\n    @param alphabet : List with letters\n    @param padding : Optional with int value\n    @return  string value corresponded to int\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_0", "requirements": "", "code": "## main.py\n\nfrom functools import wraps\n\ndef unit_of_work(metadata=None, timeout=None):\n    \"\"\"\n    Decorator function that adds metadata and timeout information before executing the decorated function.\n\n    Args:\n        metadata (str): Metadata information to be printed before function execution.\n        timeout (int): Timeout value to be printed before function execution.\n\n    Returns:\n        function: The decorated function.\n    \"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            print(f'Metadata: {metadata}, Timeout: {timeout}')\n            result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@unit_of_work(metadata=\"Example metadata\", timeout=10)\ndef example_function():\n    \"\"\"\n    Example function that gets decorated by `unit_of_work`.\n\n    Returns:\n        str: A message indicating the function has been executed.\n    \"\"\"\n    return \"Function executed successfully.\"\n\nif __name__ == \"__main__\":\n    # Test the decorated function\n    result = example_function()\n    print(result)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def unit_of_work(metadata=None, timeout=None):\n    \"\"\"Returns a decorator with metadata and timeout attributes.\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def unit_of_work(metadata=None, timeout=None):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            print(f'Metadata: {metadata}, Timeout: {timeout}')\n            result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_9", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_30", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_38", "requirements": "", "code": "## main.py\n\ndef replace_dots(value: str, arg: str = '_') -> str:\n    \"\"\"\n    Replaces all dots ('.') in the input string `value` with the specified argument `arg`.\n    \n    Args:\n        value (str): The input string containing dots to be replaced.\n        arg (str): The replacement string for each dot. Defaults to '_'.\n        \n    Returns:\n        str: The modified string with dots replaced by `arg`.\n    \"\"\"\n    return value.replace('.', arg)\n\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def replace_dots(value, arg):\n\t\"\"\"\n\tReplaces all values of '.' to arg from the given string\n    Args:\n        value: old string\n        arg: new string to replace '.'\n    Returns:\n        str, the replaced string\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def replace_dots(value: str, arg: str) -> str:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_48", "requirements": "", "code": "## main.py\n\ndef match(filename: str) -> bool:\n    \"\"\"Check if the provided filename matches 'doxyfile' in lowercase.\n\n    Args:\n        filename (str): The name of the file to check.\n\n    Returns:\n        bool: True if the filename is 'doxyfile' in lowercase, False otherwise.\n    \"\"\"\n    return filename.lower() == \"doxyfile\"\n\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def match(filename):\n\t\"\n\tCheck if the type of the given filename is 'doxyfile'\n\n    Args:\n        filename: filename to be check\n    Returns:\n        Return True if the type of the given filename in lower case is 'doxyfile'\n\t\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `match` takes a single argument `filename` (string) and returns a boolean value indicating whether the filename is 'doxyfile' in lowercase.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_37", "requirements": "", "code": "## main.py\n\nfrom typing import Dict\n\ndef _replace_register(flow_params: Dict[int, int], register_number: int, register_value: int) -> None:\n    \"\"\"\n    Replace the value of flow_params[register_number] with register_value\n    and delete flow_params[register_value].\n\n    Args:\n        flow_params (Dict[int, int]): The dictionary containing register numbers as keys and their values.\n        register_number (int): The register number whose value needs to be replaced.\n        register_value (int): The new value for the specified register number.\n\n    Returns:\n        None\n    \"\"\"\n    # Check if the register number exists in the dictionary\n    if register_number in flow_params:\n        # Replace the value of the specified register number\n        flow_params[register_number] = register_value\n    \n    # Check if the register value exists in the dictionary before deleting\n    if register_value in flow_params:\n        del flow_params[register_value]\n\n# Example usage\nif __name__ == \"__main__\":\n    flow_params_example = {0: 10, 1: 20, 2: 30}\n    _replace_register(flow_params_example, 1, 2)\n    print(flow_params_example)  # Expected output: {0: 10, 1: 30, 2: 30}\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def _replace_register(flow_params, register_number, register_value):\n    Replace the value of flow_params[register_number] with flow_params[register_value] and delete flow_params[register_value]", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def _replace_register(flow_params: dict, register_number: int, register_value: int) -> None:\n    Replace the value of flow_params[register_number] with flow_params[register_value] and delete flow_params[register_value]", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_42", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_46", "requirements": "", "code": "## main.py\n\nimport os\nfrom pathlib import PosixPath\nfrom typing import Optional, Union\nimport tarfile\nimport zipfile\n\ndef prepare_repository_from_archive(\n    archive_path: str,\n    filename: Optional[str] = None,\n    tmp_path: Union[PosixPath, str] = \"/tmp\"\n) -> str:\n    \"\"\"\n    Extracts a repository from an archive file and returns the file URL of the extracted repository.\n\n    Args:\n        archive_path (str): Path to the archive file.\n        filename (Optional[str]): Optional parameter for specifying the file name within the archive.\n        tmp_path (Union[PosixPath, str]): Path to the temporary directory where the archive will be extracted.\n\n    Returns:\n        str: File URL of the extracted repository.\n    \"\"\"\n    # Ensure tmp_path is a PosixPath object\n    tmp_path = PosixPath(tmp_path)\n\n    # Create the temporary directory if it doesn't exist\n    tmp_path.mkdir(parents=True, exist_ok=True)\n\n    # Extract the archive to the temporary directory\n    extract_archive(archive_path, tmp_path)\n\n    # Return the file URL of the extracted repository\n    return f\"file://{tmp_path}\"\n\ndef extract_archive(archive_path: str, output_dir: PosixPath):\n    \"\"\"\n    Extracts an archive file to the specified output directory.\n\n    Args:\n        archive_path (str): Path to the archive file.\n        output_dir (PosixPath): Directory where the archive will be extracted.\n    \"\"\"\n    if archive_path.endswith('.tar.gz') or archive_path.endswith('.tgz'):\n        with tarfile.open(archive_path, 'r:gz') as tar:\n            tar.extractall(path=output_dir)\n    elif archive_path.endswith('.zip'):\n        with zipfile.ZipFile(archive_path, 'r') as zip_ref:\n            zip_ref.extractall(output_dir)\n    else:\n        raise ValueError(f\"Unsupported archive format: {archive_path}\")\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def prepare_repository_from_archive(\n    archive_path: str,\n    filename: Optional[str] = None,\n    tmp_path: Union[PosixPath, str] = \"/tmp\",\n) -> str:\n\t\"\n\tGiven an existing archive_path, uncompress it.\n    Returns a file repo url which can be used as origin url.\n\n    This does not deal with the case where the archive passed along does not exist.\n    @param archive_path : archive file path\n    @param filename: File name\n    @param tmp_path: Temporary file path\n    @return Repo URL\n\t\"\n", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `prepare_repository_from_archive` has the following signature:\n```python\ndef prepare_repository_from_archive(archive_path: str, filename: Optional[str] = None, tmp_path: Union[PosixPath, str] = \"/tmp\") -> str:\n```\n- `archive_path`: Path to the archive file (string).\n- `filename`: Optional parameter for specifying the file name within the archive (string).\n- `tmp_path`: Path to the temporary directory where the archive will be extracted (string or PosixPath).\n- Returns a string representing the file URL of the extracted repository.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_4", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_18", "requirements": "", "code": "from typing import List\nimport zipfile\n\n\ndef files_list_from_zipfile(zip_path: str) -> List[str]:\n    \"\"\"\n    Return the files in the given zip path.\n    :param zip_path: Path to the zip file\n    :return: List of file names in the zip file\n    \"\"\"\n    with zipfile.ZipFile(zip_path, 'r') as zip_file:\n        return zip_file.namelist()\n\n\ndef main():\n    # Example usage\n    zip_path = 'example.zip'\n    file_list = files_list_from_zipfile(zip_path)\n    print(file_list)\n\n\nif __name__ == \"__main__\":\n    main()\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def files_list_from_zipfile(zip_path):\n    \"\"\"\n    Return the files in the given zip path.\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def files_list_from_zipfile(zip_path: str) -> List[str]:\n    \"\"\"\n    Return the files in the given zip path.\n    :param zip_path: Path to the zip file\n    :return: List of file names in the zip file\n    \"\"\"", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_26", "requirements": "", "code": "## main.py\nimport argparse\n\ndef parser_flags(parser: argparse.ArgumentParser) -> str:\n    \"\"\"Generate a string containing space-separated argument flags from an ArgumentParser object.\n\n    Args:\n        parser (argparse.ArgumentParser): The ArgumentParser object to extract flags from.\n\n    Returns:\n        str: A string containing space-separated argument flags.\n    \"\"\"\n    # Extract all actions from the parser\n    actions = parser._actions\n    \n    # Initialize an empty list to store the flags\n    flags_list = []\n    \n    # Iterate over each action and extract the flags\n    for action in actions:\n        # Skip help action\n        if action.option_strings == ['--help']:\n            continue\n        \n        # Add flags to the list\n        for flag in action.option_strings:\n            flags_list.append(flag)\n    \n    # Join the list into a single string separated by spaces\n    flags_string = ' '.join(flags_list)\n    \n    return flags_string\n\n# Example usage\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--flag1', type=str, help='First flag')\n    parser.add_argument('--flag2', type=int, help='Second flag')\n    print(parser_flags(parser))\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def parser_flags(parser):\n\t\"\n\tGiven an argparse.ArgumentParser instance, return its argument flags in a space-separated\nstring.\n\t\"\n", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `parser_flags` takes one parameter:\n- `parser`: argparse.ArgumentParser (input)\nIt returns a string containing space-separated argument flags.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_19", "requirements": "", "code": "## main.py\n\ndef fix_namespace_prefix_w(content: str) -> str:\n    \"\"\"Fixes namespace prefix in the provided XML content.\n\n    Args:\n        content (str): The XML content string to be processed.\n\n    Returns:\n        str: The processed XML content with fixed namespace prefixes.\n    \"\"\"\n    # Define the pattern to match the namespace prefix\n    pattern = r'\\{http://www.w3.org/2001/XMLSchema-instance\\}'\n\n    # Replace the matched pattern with an empty string\n    fixed_content = re.sub(pattern, '', content)\n\n    return fixed_content\n\n\nif __name__ == \"__main__\":\n    import re\n\n    # Example usage\n    xml_content = '<root xmlns:xi=\"http://www.w3.org/2001/XMLSchema-instance\"><element xi:schemaLocation=\"http://example.com/schema\"/></root>'\n    print(fix_namespace_prefix_w(xml_content))\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def fix_namespace_prefix_w(content):\n    \"\"\"\n    Replace \"w:st=\" in content with \"w-st=\".\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def fix_namespace_prefix_w(content: str) -> str:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_2", "requirements": "", "code": "## main.py\nfrom typing import List\n\ndef _inline_r_setup(code: str) -> str:\n    \"\"\"Some behavior of R cannot be configured via env variables, but can\n    only be configured via R options once R has started. These are set here.\n    \n    Args:\n        code (str): The R code to be executed.\n        \n    Returns:\n        str: The modified R code with necessary setup options.\n    \"\"\"\n    # Example setup options\n    setup_options = [\n        \"options(scipen=999)\",  # Avoid scientific notation\n        \"options(stringsAsFactors = FALSE)\"  # Keep strings as strings\n    ]\n    \n    # Join the setup options into a single string separated by newlines\n    setup_code = \"\\n\".join(setup_options)\n    \n    # Combine the setup code with the provided code\n    return f\"{setup_code}\\n{code}\"\n\ndef execute_r_code(r_code: str) -> None:\n    \"\"\"Executes the provided R code after setting up necessary configurations.\n    \n    Args:\n        r_code (str): The R code to be executed.\n    \"\"\"\n    # Setup the R environment\n    setup_code = _inline_r_setup(r_code)\n    \n    # Here would be the logic to execute the R code, for demonstration purposes,\n    # we'll just print the setup code.\n    print(\"Executing R code with setup:\")\n    print(setup_code)\n\nif __name__ == \"__main__\":\n    # Example usage\n    r_code = \"print('Hello, World!')\"\n    execute_r_code(r_code)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def _inline_r_setup(code: str) -> str:\\n    \\\"\\\"\\\"Some behaviour of R cannot be configured via env variables, but can\\nonly be configured via R options once R has started. These are set here.\\n    \\\"\\\"\\\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def _inline_r_setup(code: str) -> str:\n    \"\"\"Some behavior of R cannot be configured via env variables, but can\n    only be configured via R options once R has started. These are set here.\n    \"\"\"", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_57", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_33", "requirements": "", "code": "## main.py\n\nimport argparse\n\ndef parser_flags(parser: argparse.ArgumentParser) -> str:\n    \"\"\"Extracts and returns space-separated argument flags from an ArgumentParser instance.\n\n    Args:\n        parser (argparse.ArgumentParser): An instance of ArgumentParser.\n\n    Returns:\n        str: A string containing space-separated argument flags.\n    \"\"\"\n    # Extract all actions from the parser\n    actions = parser._actions\n    \n    # Initialize a list to store the flags\n    flags_list = []\n    \n    # Iterate over each action and extract the flags\n    for action in actions:\n        # Skip help action\n        if action.option_strings == ['--help']:\n            continue\n        \n        # Add flags to the list\n        for flag in action.option_strings:\n            flags_list.append(flag)\n    \n    # Join the list into a single string separated by spaces\n    flags_string = ' '.join(flags_list)\n    \n    return flags_string\n\n\n# Example usage\nif __name__ == \"__main__\":\n    # Create an ArgumentParser instance\n    parser = argparse.ArgumentParser(description=\"Example Argument Parser\")\n    \n    # Add some arguments\n    parser.add_argument('--flag1', action='store_true', help='Flag 1')\n    parser.add_argument('--flag2', type=str, help='Flag 2')\n    parser.add_argument('-f', '--file', type=str, help='Input file')\n    \n    # Call the function and print the result\n    print(parser_flags(parser))\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def parser_flags(parser):\n\t\"\n\tGiven an argparse.ArgumentParser instance, return its argument flags in a space-separated string.\n    Args:\n        script: argparse.ArgumentParser instance\n\n    Returns:\n        argument flags in a space-separated string\n\t\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `parser_flags` takes an `argparse.ArgumentParser` instance as input and returns a string. The input is an instance of `argparse.ArgumentParser`, and the output is a string containing space-separated argument flags.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_24", "requirements": "", "code": "## main.py\n\nfrom typing import Callable\n\ndef register_vcs_handler(vcs: str, method: Callable) -> Callable:\n    \"\"\"\n    Registers a handler for a version control system (VCS).\n\n    Args:\n        vcs (str): The name of the VCS.\n        method (Callable): The method to be registered as a handler.\n\n    Returns:\n        Callable: The original method passed as an argument.\n    \"\"\"\n    # In a real implementation, this would likely involve storing the method\n    # in a dictionary or similar data structure keyed by the VCS name.\n    # Here we simply return the method as a placeholder.\n    return method\n\n# Example usage\ndef git_handler():\n    print(\"Handling Git operations\")\n\ndef hg_handler():\n    print(\"Handling Mercurial operations\")\n\nregister_vcs_handler('git', git_handler)\nregister_vcs_handler('hg', hg_handler)\n\n# Triggering the handlers\ngit_handler()  # Should print \"Handling Git operations\"\nhg_handler()   # Should print \"Handling Mercurial operations\"\n\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def register_vcs_handler(vcs, method):\n    \"\"\"Create decorator to mark a method as the handler of a object\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def register_vcs_handler(vcs: str, method: callable) -> callable: ...", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_52", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_32", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_3", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_58", "requirements": "", "code": "## main.py\n\ndef remove_ending_os_sep(input_list: list[str]) -> list[str]:\n    \"\"\"Removes trailing path separators from each string in the input list.\n\n    Args:\n        input_list (list[str]): A list of strings potentially containing trailing path separators.\n\n    Returns:\n        list[str]: A new list of strings with trailing path separators removed.\n    \"\"\"\n    return [s.rstrip(os.sep) for s in input_list]\n\nimport os\n\n# Example usage\nif __name__ == \"__main__\":\n    test_input = [\"path/to/file/\", \"another/path/\", \"/root/path/\"]\n    print(remove_ending_os_sep(test_input))\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def remove_ending_os_sep(input_list):\n\t\"\"\"\n\tIf input list is None, return []\n    Iterate over a string list and remove trailing os seperator characters.\n    Each string is tested if its length is greater than one and if the last\n    character is the pathname seperator.\n    Returns:\n    A list after removing trailing os seperator characters.\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `remove_ending_os_sep` takes a list of strings (`input_list`) as input and returns a list of strings after removing trailing path separators.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_25", "requirements": "", "code": "## main.py\nimport argparse\n\ndef parser_flags(parser: argparse.ArgumentParser) -> str:\n    \"\"\"\n    Parses command line arguments and returns a string representation of the parsed flags.\n\n    Args:\n        parser (argparse.ArgumentParser): The argument parser object to use for parsing.\n\n    Returns:\n        str: A string representation of the parsed flags.\n    \"\"\"\n    # Add some example flags to the parser\n    parser.add_argument('--flag1', type=str, help='A sample flag')\n    parser.add_argument('--flag2', type=int, default=0, help='Another sample flag with a default value')\n\n    # Parse the arguments\n    args = parser.parse_args()\n\n    # Return a string representation of the parsed flags\n    return f\"Flag1: {args.flag1}, Flag2: {args.flag2}\"\n\nif __name__ == \"__main__\":\n    # Create an ArgumentParser object\n    parser = argparse.ArgumentParser(description=\"Example script to parse command line flags\")\n\n    # Call the function to parse the flags\n    result = parser_flags(parser)\n\n    # Print the result\n    print(result)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def parser_flags(parser):\n    \"\"\"\n    Given an argparse.ArgumentParser instance, return its argument flags in a space-separated\n    string.\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def parser_flags(parser: argparse.ArgumentParser) -> str:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_22", "requirements": "", "code": "## main.py\nfrom datetime import datetime\nimport pytz\n\ndef from_utc(dt: datetime, original_tz: str, target_tz: str) -> datetime:\n    \"\"\"\n    Converts a datetime object from one timezone to another.\n    \n    :param dt: A datetime object representing the original datetime\n    :param original_tz: A string representing the original timezone (e.g., 'US/Eastern')\n    :param target_tz: A string representing the target timezone (e.g., 'Asia/Tokyo')\n    :return: A datetime object representing the converted datetime in the target timezone\n    \"\"\"\n    # Ensure the datetime object is naive\n    if dt.tzinfo is not None:\n        raise ValueError(\"The datetime object must be naive (without timezone information)\")\n    \n    # Convert the original datetime to UTC\n    original_timezone = pytz.timezone(original_tz)\n    localized_dt = original_timezone.localize(dt)\n    utc_dt = localized_dt.astimezone(pytz.utc)\n\n    # Convert the UTC datetime to the target timezone\n    target_timezone = pytz.timezone(target_tz)\n    target_dt = utc_dt.astimezone(target_timezone)\n\n    return target_dt\n\n# Example usage\nif __name__ == \"__main__\":\n    original_datetime = datetime(2023, 10, 1, 12, 0, 0)\n    original_timezone_str = 'US/Eastern'\n    target_timezone_str = 'Asia/Tokyo'\n\n    converted_datetime = from_utc(original_datetime, original_timezone_str, target_timezone_str)\n    print(f\"Converted Datetime: {converted_datetime}\")\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def _fromutc(self, dt):\n    \"\"\"Given a timezone datetime in a given timezone, calculates a timezone datetime in a new timezone.\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def from_utc(dt: datetime, original_tz: str, target_tz: str) -> datetime:\n    Converts a datetime object from one timezone to another.\n    :param dt: A datetime object representing the original datetime\n    :param original_tz: A string representing the original timezone (e.g., 'US/Eastern')\n    :param target_tz: A string representing the target timezone (e.g., 'Asia/Tokyo')\n    :return: A datetime object representing the converted datetime in the target timezone", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_50", "requirements": "", "code": "## main.py\n\nimport ipaddress\nimport socket\n\ndef resolve_host(host: str) -> str:\n    \"\"\"Resolve a host name to its corresponding IP address.\n\n    Args:\n        host (str): The host name to resolve.\n\n    Returns:\n        str: The IP address of the host, or None if resolution fails.\n    \"\"\"\n    try:\n        return socket.gethostbyname(host)\n    except socket.gaierror:\n        return None\n\ndef is_local(host: str) -> bool:\n    \"\"\"Check if the host is a local address.\n\n    Args:\n        host (str): The host address to check.\n\n    Returns:\n        bool: True if the host is a local address, False otherwise.\n    \"\"\"\n    # Resolve the host to an IP address if it's a domain name\n    resolved_host = resolve_host(host)\n    if resolved_host:\n        host = resolved_host\n\n    # Define a list of common local IP ranges\n    local_ip_ranges = [\n        \"127.0.0.1\",\n        \"localhost\",\n        \"192.168.0.0/16\",\n        \"10.0.0.0/8\",\n        \"172.16.0.0/12\"\n    ]\n\n    try:\n        ip = ipaddress.ip_address(host)\n        if isinstance(ip, ipaddress.IPv4Address):\n            return ip.is_private\n        elif isinstance(ip, ipaddress.IPv6Address):\n            return ip.is_link_local or ip.is_loopback\n    except ValueError:\n        pass\n\n    # Check if the host matches any of the local IP ranges\n    for ip_range in local_ip_ranges:\n        if ipaddress.ip_network(ip_range).overlaps(ipaddress.ip_network(host)):\n            return True\n\n    return False\n\n\n# Example usage\nif __name__ == \"__main__\":\n    print(is_local(\"127.0.0.1\"))  # Expected output: True\n    print(is_local(\"192.168.1.1\"))  # Expected output: True\n    print(is_local(\"10.0.0.1\"))  # Expected output: True\n    print(is_local(\"172.16.0.1\"))  # Expected output: True\n    print(is_local(\"8.8.8.8\"))  # Expected output: False\n    print(is_local(\"google.com\"))  # Expected output: False\n    print(is_local(\"::1\"))  # Expected output: True\n    print(is_local(\"fe80::1\"))  # Expected output: True\n    print(is_local(\"2001:db8::\"))  # Expected output: False\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def is_local(host):\n\t\"\"\"\n\tChecks if the host is the localhost,\n    the localhost include local IP, user name, local domain name, `localhost` and `127.0.0.1`\n\n    Args:\n        host: The hostname or ip\n\n    Returns:\n        True if the host is the localhost else False\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def is_local(host: str) -> bool:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_7", "requirements": "", "code": "from typing import List, Any\n\ndef _legacy_mergeOrderings(orderings: List[List[Any]]) -> List[Any]:\n    \"\"\"Merge multiple orderings into a single ordering without duplicates.\n\n    Args:\n        orderings (List[List[Any]]): A list of orderings, where each ordering is a list of elements.\n\n    Returns:\n        List[Any]: A single merged ordering containing all unique elements from the input orderings.\n    \"\"\"\n    merged_list = list(set().union(*orderings))\n    return merged_list\n\n# Example usage\nif __name__ == \"__main__\":\n    orderings = [\n        [1, 2, 3],\n        [2, 3, 4],\n        [3, 4, 5]\n    ]\n    print(_legacy_mergeOrderings(orderings))  # Output: [1, 2, 3, 4, 5]\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def _legacy_mergeOrderings(orderings):\n    \n    Combine multiple lists in the sequence of occurrence into a list with no duplicate elements.", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def _legacy_mergeOrderings(orderings: List[List[Any]]) -> List[Any]:\n    merged_list = list(set().union(*orderings))\n    return merged_list", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_5", "requirements": "", "code": "from typing import Any\n\nclass DictionaryWrapper:\n    def __init__(self, dictionary: dict):\n        self._dictionary = dictionary\n\n    def get(self, key: str, default: Any = None) -> Any:\n        \"\"\"\n        If a key exists in the dictionary, the value corresponding to the key is returned. Otherwise, default is returned.\n        \"\"\"\n        return self._dictionary.get(key, default)\n\n# Example usage\nif __name__ == \"__main__\":\n    my_dict = DictionaryWrapper({\"a\": 1, \"b\": 2})\n    print(my_dict.get(\"a\"))  # Output: 1\n    print(my_dict.get(\"c\", \"Not found\"))  # Output: Not found\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def get(self, key, default=None):\n    \\\"\\\"\\\n    If a key exists in the class, the value corresponding to the key is returned. Otherwise, default is returned.\n    \\\"\\\"\\\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def get(key: str, default: typing.Any = None) -> typing.Any:\n    \\\"\\\"\\\n    If a key exists in the dictionary, the value corresponding to the key is returned. Otherwise, default is returned.\n    \\\"\\\"\\\"", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_55", "requirements": "", "code": "## main.py\n\nimport subprocess\nfrom typing import Callable, Any, Optional, Dict\nfrom subprocess import CompletedProcess\nimport os\nimport sys\nimport shlex\n\n\ndef subprocess_run_helper(\n    func: Callable[..., Any],\n    *args: Any,\n    timeout: Optional[float] = None,\n    extra_env: Optional[Dict[str, str]] = None,\n) -> CompletedProcess:\n    \"\"\"Runs a function in a subprocess with optional timeout and environment variables.\n\n    Args:\n        func (Callable[..., Any]): The function to be executed in the subprocess.\n        *args (Any): Variable length argument list that can be passed to the function.\n        timeout (Optional[float], optional): Maximum time in seconds that the subprocess is allowed to run. Defaults to None.\n        extra_env (Optional[Dict[str, str]], optional): Additional environment variables to be set for the subprocess. Defaults to None.\n\n    Returns:\n        CompletedProcess: Information about the execution of the subprocess.\n    \"\"\"\n    # Prepare the environment\n    env = dict(extra_env) if extra_env else {}\n    env.update(os.environ)\n\n    # Prepare the command to be executed\n    command = [\n        sys.executable,\n        \"-c\",\n        shlex.quote(f\"import sys; from {func.__module__} import {func.__name__}; sys.exit({func.__name__}(*{args}))\")\n    ]\n\n    # Run the subprocess\n    process = subprocess.Popen(\n        command,\n        env=env,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE\n    )\n\n    try:\n        process.wait(timeout=timeout)\n    except subprocess.TimeoutExpired:\n        process.terminate()\n        process.wait()\n\n    # Capture the output and error streams\n    stdout, stderr = process.communicate()\n\n    # Return the completed process information\n    return CompletedProcess(\n        args=args,\n        returncode=process.returncode,\n        stdout=stdout,\n        stderr=stderr\n    )\n\n\n# Example usage\nif __name__ == \"__main__\":\n    def example_function():\n        print(\"Hello from subprocess!\")\n        return 0\n\n    result = subprocess_run_helper(example_function, timeout=5)\n    print(result)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def subprocess_run_helper(func, *args, timeout, extra_env=None):\n    \"\"\"Run a function in a sub-process\n\n    Args:\n            func: function, the function to be run. It must be in a module that is importable.\n            *args: str. Any additional command line arguments to be passed in\n                        the first argument to ``subprocess.run``.\n            extra_env: dict[str, str]. Any additional environment variables to be set for the subprocess.\n    Returns:\n            CompletedProcess instance\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `subprocess_run_helper` takes the following parameters:\n- `func`: A callable function that needs to be executed in a subprocess.\n- `*args`: Variable length argument list that can be passed to the function being executed.\n- `timeout`: An integer or float representing the maximum time in seconds that the subprocess is allowed to run before it is terminated.\n- `extra_env`: An optional dictionary containing additional environment variables to be set for the subprocess.\nThe function returns a `CompletedProcess` instance which contains information about the execution of the subprocess.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_28", "requirements": "", "code": "## main.py\n\ndef size_to_bytes(size: str) -> int:\n    \"\"\"Converts a human-readable file size string to bytes.\n\n    Args:\n        size (str): A string representing a human-readable file size, e.g., '500K', '1M', '2G'.\n\n    Returns:\n        int: The file size in bytes.\n\n    Raises:\n        ValueError: If the size string contains an invalid number format or an unknown unit.\n    \"\"\"\n    units = {\n        'B': 1,\n        'KB': 1024,\n        'MB': 1024**2,\n        'GB': 1024**3,\n        'TB': 1024**4,\n    }\n\n    # Split the size into numeric and unit parts\n    num_str, unit_str = size[:-1], size[-1].upper()\n\n    # Handle single-character units\n    if len(unit_str) == 1:\n        unit_str += 'B'\n\n    # Convert the numeric part to an integer\n    try:\n        num = int(num_str)\n    except ValueError:\n        raise ValueError(f\"Invalid number format in size string: {size}\")\n\n    # Get the corresponding multiplier for the unit\n    if unit_str not in units:\n        raise ValueError(f\"Unknown unit '{unit_str}' in size string: {size}\")\n    \n    return num * units[unit_str]\n\n# Example usage\nif __name__ == \"__main__\":\n    print(size_to_bytes(\"500K\"))  # Output: 512000\n    print(size_to_bytes(\"1M\"))    # Output: 1048576\n    print(size_to_bytes(\"2G\"))    # Output: 2147483648\n    print(size_to_bytes(\"10T\"))   # Output: 10995116277760\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def size_to_bytes(size: str) -> int:\\n\\t\"\"\"\\n\\tConvert human readable file size to bytes\\n\\n\\tArgs:\\n\\t        size: str, a string representing a human readable file size (eg: '500K')\\n\\tReturns:\\n\\t        int: file size in bytes\\n\\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `size_to_bytes` takes a single argument `size` which is a string representing a human-readable file size (e.g., '500K', '1M', '2G'). It returns an integer representing the file size in bytes.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_35", "requirements": "", "code": "from typing import List, Tuple\n\ndef vertex3tuple(vertices: List[int]) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Takes a list of vertices and returns a list of tuples. Each tuple contains three points:\n    the current vertex and its two neighbors.\n    \n    Args:\n        vertices (List[int]): A list of integers representing vertices.\n        \n    Returns:\n        List[Tuple[int, int, int]]: A list of tuples where each tuple contains three integers:\n            the current vertex and its two neighbors.\n    \"\"\"\n    if not vertices or len(vertices) < 3:\n        return []\n    \n    result = []\n    n = len(vertices)\n    \n    for i in range(n):\n        # Handle the first vertex\n        if i == 0:\n            result.append((vertices[i], vertices[i + 1], vertices[(i + 2) % n]))\n        # Handle the last vertex\n        elif i == n - 1:\n            result.append((vertices[i], vertices[i - 1], vertices[0]))\n        else:\n            result.append((vertices[i], vertices[i - 1], vertices[i + 1]))\n    \n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    vertices = [1, 2, 3, 4]\n    print(vertex3tuple(vertices))\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def vertex3tuple(vertices):\n\t\"\"\"\n\tGet 3 points for each vertex of the polygon.\n    This will include the vertex and the 2 points on both sides of the vertex\n    If the subscript is out of bounds, take the value of index as 0\n    Args:\n        vertices: vertices to be converted\n\n    Returns:\n        A list where the elements of vertices represented by tuple\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `vertex3tuple` takes a list of vertices (list) and returns a list of tuples. Each tuple contains three points: the current vertex and its two neighbors.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_31", "requirements": "", "code": "## main.py\n\nfrom typing import Any\n\ndef is_none_string(val: Any) -> bool:\n    \"\"\"Check if the provided value is None or an empty string.\n\n    Args:\n        val (Any): The value to check.\n\n    Returns:\n        bool: True if the value is None or an empty string, False otherwise.\n    \"\"\"\n    return val is None or (isinstance(val, str) and val.strip() == '')\n\n# Example usage\nif __name__ == \"__main__\":\n    print(is_none_string(None))          # True\n    print(is_none_string(\"\"))           # True\n    print(is_none_string(\"   \"))        # True\n    print(is_none_string(\"Hello\"))      # False\n    print(is_none_string(123))          # False\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def is_none_string(val: any) -> bool:\\n\\t\\\"\\\"\\\" Check if a string represents a None value.\\n    Returns:\\n        Return True if the type of val is string and the lowercase of val is equal to 'none', otherwise return False\\n    \\\"\\\"\\\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def is_none_string(val: any) -> bool:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_1", "requirements": "", "code": "## main.py\n\ndef round_half_to_even(n: float) -> int:\n    \"\"\"\n    Rounds a floating-point number to the nearest integer, rounding half to even.\n    \n    This function implements the \"round half to even\" rule, also known as \"bankers' rounding\".\n    It rounds .5 up to the nearest even number, which reduces bias in statistical computations.\n    \n    Args:\n        n (float): The floating-point number to round.\n        \n    Returns:\n        int: The rounded integer.\n    \"\"\"\n    # Get the decimal part of the number\n    decimal_part = n % 1\n\n    # Handle positive numbers\n    if decimal_part > 0.5 or (decimal_part == 0.5 and int(n) % 2 != 0):\n        return int(n + 0.5)\n    elif decimal_part < 0.5 or (decimal_part == 0.5 and int(n) % 2 == 0):\n        return int(n)\n\n    # Handle negative numbers\n    if decimal_part < -0.5 or (decimal_part == -0.5 and int(n) % 2 != 0):\n        return int(n - 0.5)\n    elif decimal_part >= -0.5 or (decimal_part == -0.5 and int(n) % 2 == 0):\n        return int(n)\n\n# Example usage\nif __name__ == \"__main__\":\n    print(round_half_to_even(2.5))  # Should print 2\n    print(round_half_to_even(3.5))  # Should print 4\n    print(round_half_to_even(-2.5)) # Should print -2\n    print(round_half_to_even(-3.5)) # Should print -4\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def round_half_to_even(n):\n    \"\"\"\n    Round a floating-point number\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def round_half_to_even(n: float) -> int:\n    \"\"\"\n    Rounds a floating-point number to the nearest integer, rounding half to even.\n    :param n: A floating-point number\n    :return: An integer representing the rounded value\n    \"\"\"", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_62", "requirements": "", "code": "from datetime import datetime, timezone\n\ndef default_tzinfo(dt: datetime, tzinfo: timezone = timezone.utc) -> datetime:\n    \"\"\"\n    Takes a datetime object and assigns it a timezone if it is naive (i.e., lacks timezone info).\n    \n    Args:\n        dt (datetime): The datetime object to check and modify.\n        tzinfo (timezone): The timezone info to assign to the datetime object if it is naive.\n                           Defaults to UTC timezone.\n    \n    Returns:\n        datetime: An aware datetime object with timezone info.\n    \"\"\"\n    if dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None:\n        return dt.replace(tzinfo=tzinfo)\n    else:\n        return dt\n\n# Example usage\nif __name__ == \"__main__\":\n    naive_dt = datetime(2023, 1, 1, 12, 0, 0)\n    aware_dt = default_tzinfo(naive_dt)\n    print(\"Naive datetime:\", naive_dt)\n    print(\"Aware datetime:\", aware_dt)\n\n    # Using custom timezone\n    custom_tz = timezone(offset=-timedelta(hours=5))\n    custom_aware_dt = default_tzinfo(naive_dt, custom_tz)\n    print(\"Custom aware datetime:\", custom_aware_dt)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def default_tzinfo(dt, tzinfo):\n\t\"\"\"\n\tSets the ``tzinfo`` parameter on naive datetimes only\n\nThis is useful for example when you are provided a datetime that may have\nan implicit or explicit time zone, such as when parsing a time zone\nstring.\n\n.. doctest::\n\n    >>> from dateutil.tz import tzoffset\n    >>> from dateutil.parser import parse\n    >>> from dateutil.utils import default_tzinfo\n    >>> dflt_tz = tzoffset(\"EST\", -18000)\n    >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n    2014-01-01 12:30:00+00:00\n    >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n    2014-01-01 12:30:00-05:00\n\n:param dt:\n    The datetime on which to replace the time zone\n\n:param tzinfo:\n    The :py:class:`datetime.tzinfo` subclass instance to assign to\n    ``dt`` if (and only if) it is naive.\n\n:return:\n    Returns an aware :py:class:`datetime.datetime`.\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `default_tzinfo` takes two parameters:\n\n- `dt`: A `datetime.datetime` object representing the datetime to be checked and possibly modified.\n- `tzinfo`: A `datetime.tzinfo` subclass instance representing the timezone information to be assigned to `dt` if it is naive.\n\nThe function returns an `aware` `datetime.datetime` object.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_47", "requirements": "", "code": "## main.py\n\ndef add_ignored(ignored: str) -> str:\n    \"\"\"Takes a comma-separated string of filenames and returns a sorted, comma-separated string of filenames.\n\n    Args:\n        ignored (str): A comma-separated string of filenames.\n\n    Returns:\n        str: A sorted, comma-separated string of filenames.\n    \"\"\"\n    # Split the input string into a list of filenames\n    filenames = ignored.split(',')\n\n    # Remove any leading/trailing whitespace from each filename\n    filenames = [filename.strip() for filename in filenames]\n\n    # Sort the list of filenames\n    filenames.sort()\n\n    # Join the sorted list back into a single string, separated by commas\n    return ','.join(filenames)\n\n\n# Example usage\nif __name__ == \"__main__\":\n    ignored_files = \"file3.txt, file1.txt, file2.txt\"\n    sorted_files = add_ignored(ignored_files)\n    print(sorted_files)  # Expected output: \"file1.txt,file2.txt,file3.txt\"\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def addignored(ignored):\n\t\"\"\"\n\tUse the git command to obtain the file names\n    Turn the file names into a list, sort the list for only ignored files\n    return those files as a single string with each filename separated by a comma.\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `addignored` takes a string `ignored` as input and returns a string containing the sorted filenames separated by commas.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_10", "requirements": "", "code": "## main.py\n\nfrom typing import List\n\ndef _c_optimizations_required() -> bool:\n    \"\"\"Check if C optimizations are required.\n\n    Returns:\n        bool: True if C optimizations are required, False otherwise.\n    \"\"\"\n    # Actual logic for checking if C optimizations are required\n    # Example: Check if the system supports certain features\n    # Here we can add more sophisticated logic, such as checking environment variables or system capabilities\n    # For demonstration purposes, let's assume we are checking an environment variable\n    import os\n    return os.environ.get('ENABLE_C_OPTIMIZATIONS', '').lower() == 'true'\n\ndef perform_optimizations(optimization_list: List[str] = [\"C\"]) -> None:\n    \"\"\"Perform optimizations based on the provided list.\n\n    Args:\n        optimization_list (List[str]): List of optimizations to perform. Defaults to [\"C\"].\n    \"\"\"\n    for optimization in optimization_list:\n        if optimization == \"C\":\n            if _c_optimizations_required():\n                print(\"Performing C optimizations...\")\n            else:\n                print(\"No C optimizations required.\")\n        else:\n            print(f\"Optimization {optimization} not supported.\")\n\nif __name__ == \"__main__\":\n    perform_optimizations()\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def _c_optimizations_required():\\n    \\\"\\\"\\\" Return a true value if the C optimizations are required.\\\"\\\"\\\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def _c_optimizations_required() -> bool:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_39", "requirements": "", "code": "## main.py\n\nfrom typing import Set\n\nclass BaseClass:\n    \"\"\"Base class for demonstration purposes.\"\"\"\n    pass\n\nclass SubClassA(BaseClass):\n    \"\"\"Subclass A inheriting from BaseClass.\"\"\"\n    pass\n\nclass SubClassB(BaseClass):\n    \"\"\"Subclass B inheriting from BaseClass.\"\"\"\n    pass\n\nclass SubClassC(SubClassA):\n    \"\"\"Subclass C inheriting from SubClassA.\"\"\"\n    pass\n\ndef subclasses(cls: type) -> Set[type]:\n    \"\"\"\n    Returns a set of all subclasses of the given class.\n\n    Args:\n        cls (type): The class whose subclasses are to be found.\n\n    Returns:\n        Set[type]: A set containing all direct and indirect subclasses of `cls`.\n    \"\"\"\n    sub_classes = set()\n\n    def find_subclasses(cls: type):\n        for subclass in cls.__subclasses__():\n            sub_classes.add(subclass)\n            find_subclasses(subclass)\n\n    find_subclasses(cls)\n    return sub_classes\n\n# Example usage\nif __name__ == \"__main__\":\n    base_class_subclasses = subclasses(BaseClass)\n    print(\"Subclasses of BaseClass:\", base_class_subclasses)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def subclasses(cls):\n    \"\"\"\n    Return all subclasses of a class, recursively\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def subclasses(cls) -> set:  # Input: cls (class), Output: set of subclasses", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_20", "requirements": "", "code": "from typing import List, Optional\n\ndef match_pubdate(node, pubdate_xpaths: List[str]) -> Optional[str]:\n    \"\"\"For the given node, returns the first match in the pubdate_xpaths list.\"\"\"\n    for xpath in pubdate_xpaths:\n        pubdate = node.xpath(xpath)\n        if pubdate:\n            return pubdate[0]\n    return None\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def match_pubdate(node, pubdate_xpaths):\n    \"\"\"For the given node, returns the first match in the pubdate_xpaths list.\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def match_pubdate(node, pubdate_xpaths) -> str:\n    \"\"\"For the given node, returns the first match in the pubdate_xpaths list.\"\"\"\n    for xpath in pubdate_xpaths:\n        pubdate = node.xpath(xpath)\n        if pubdate:\n            return pubdate[0]\n    return None", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_54", "requirements": "", "code": "## main.py\n\ndef oneline(script: str, separator: str = \" && \") -> str:\n    \"\"\"Converts a script into a single line string separated by a specified separator.\n\n    Args:\n        script (str): The script to convert.\n        separator (str, optional): The separator to use between lines. Defaults to \" && \".\n\n    Returns:\n        str: The converted one-line script.\n    \"\"\"\n    # Split the script into lines\n    lines = script.splitlines()\n    \n    # Join the lines with the specified separator\n    return separator.join(lines)\n\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def oneline(script, seperator=\" && \"):\n\t\"\"\"\n\tConvert a script to one line command with the given seperator.\n\n        Args:\n                script: str\n                separator: str\n        Returns:\n                str, the one-line command.\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def oneline(script: str, separator: str = \" && \") -> str:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_8", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_40", "requirements": "", "code": "from typing import List\n\ndef string_to_int(string: str, alphabet: List[str]) -> int:\n    \"\"\"\n    Converts a string to its corresponding integer value based on a given alphabet.\n\n    Args:\n        string (str): The string to convert.\n        alphabet (List[str]): The alphabet used for conversion.\n\n    Returns:\n        int: The integer representation of the string.\n    \"\"\"\n    if not string or not alphabet:\n        raise ValueError(\"String and alphabet must not be empty.\")\n    \n    # Create a dictionary mapping each character in the alphabet to its index\n    char_to_index = {char: idx for idx, char in enumerate(alphabet)}\n    \n    # Convert the string to its integer value\n    result = 0\n    for char in string:\n        if char not in char_to_index:\n            raise ValueError(f\"Character '{char}' is not in the provided alphabet.\")\n        result = result * len(alphabet) + char_to_index[char]\n    \n    return result\n\n\n# Example usage\nif __name__ == \"__main__\":\n    string = \"abc\"\n    alphabet = [\"a\", \"b\", \"c\", \"d\"]\n    print(string_to_int(string, alphabet))  # Output should be 4 (a=0, b=1, c=2 => 0*4 + 1*1 + 2 = 4)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def string_to_int(string: str, alphabet: List[str]) -> int:\n    \"\"\"Convert a string to a number, using the given alphabet.\n    :param string: a string consist of the letters in alphabet\n    :param alphabet: list of letters\n    :return: int, the corresponding number of the given string using the given transition rule.\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `string_to_int` takes two parameters: `string` (a str) and `alphabet` (a List[str]). It returns an int which represents the numerical value of the string according to the provided alphabet.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_12", "requirements": "", "code": "## main.py\n\nfrom typing import Any\n\ndef is_run_el(obj: Any) -> bool:\n    \"\"\"Check if an object is a run-once element.\n\n    Args:\n        obj (Any): The object to check.\n\n    Returns:\n        bool: True if the object is a run-once element, False otherwise.\n    \"\"\"\n    # Define what constitutes a run-once element\n    # For this example, let's assume a run-once element is a string or integer\n    return isinstance(obj, (str, int))\n\n# Example usage\nif __name__ == \"__main__\":\n    print(is_run_el(\"Hello\"))  # Expected output: True\n    print(is_run_el(42))       # Expected output: True\n    print(is_run_el([1, 2]))   # Expected output: False\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def is_run_el(obj):\n    \\\\\"\\\\\"Check whether the obj class has the run method.\\\\\\\"\\\\\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def is_run_el(obj) -> bool:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_51", "requirements": "", "code": "## main.py\n\ndef make_find_paths(paths: list[str]) -> tuple[str]:\n    \"\"\"\n    Transforms a list of string paths into a tuple of transformed paths.\n    \n    Args:\n        paths (list[str]): A list of string paths.\n        \n    Returns:\n        tuple[str]: A tuple of transformed paths.\n    \"\"\"\n    transformed_paths = []\n    for path in paths:\n        # Example transformation: append \"_transformed\" to each path\n        transformed_path = f\"{path}_transformed\"\n        transformed_paths.append(transformed_path)\n    return tuple(transformed_paths)\n\n# Example usage\nif __name__ == \"__main__\":\n    paths = [\"path1\", \"path2\", \"path3\"]\n    transformed_paths = make_find_paths(paths)\n    print(transformed_paths)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def make_find_paths(find_paths):\n\t\"\"\"\n\tGiven a sequence of path, transform all path into glob patterns. Pass through existing patterns untouched.\n\t\n\tArgs:\n\t\tfind_paths: sequence of path\n\tReturns:\n\t\ttuple of transformed path\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `make_find_paths` takes a sequence of strings (paths) and returns a tuple of strings (transformed paths).", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_29", "requirements": "", "code": "from typing import List, Dict\n\ndef _dictsum(dicts: List[Dict[str, int]]) -> Dict[str, int]:\n    \"\"\"\n    Sum the values of common keys across multiple dictionaries.\n\n    Args:\n        dicts (List[Dict[str, int]]): A list of dictionaries containing string keys and integer values.\n\n    Returns:\n        Dict[str, int]: A dictionary with summed values for each key present in all input dictionaries.\n    \"\"\"\n    result = {}\n    # Initialize the result dictionary with the first dictionary's keys and values\n    if dicts:\n        result = dicts[0].copy()\n        # Iterate over the remaining dictionaries\n        for d in dicts[1:]:\n            for key, value in d.items():\n                # Add the value to the existing key in the result dictionary\n                if key in result:\n                    result[key] += value\n                else:\n                    result[key] = value\n    return result\n\n# Example usage\nif __name__ == \"__main__\":\n    dict_list = [\n        {\"a\": 1, \"b\": 2},\n        {\"b\": 3, \"c\": 4},\n        {\"a\": 5, \"d\": 6}\n    ]\n    print(_dictsum(dict_list))  # Expected output: {'a': 6, 'b': 5, 'c': 4, 'd': 6}\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def _dictsum(dicts):\n\t\"\"\"\n\tSum values with the same key in the dictionaries. And return a new dictionary.\n    Example:\n        given two dictionaries: dict1: {'a': 1, 'b': 2}, dict2: {'a': 5, 'b': 0}\n        return a dictionary: dic:{'a': 6, 'b': 2}\n    Returns: dict\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def _dictsum(dicts: typing.List[dict]) -> dict:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_17", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_45", "requirements": "", "code": "from typing import List\n\ndef split(s: str, platform: str = 'this') -> List[str]:\n    \"\"\"\n    Split the input str under given platform, return the splitting result\n    If platform equals 'this', auto-detect current platform.\n    If platform equals 1, use POSIX style.\n    If platform equals 0, use Windows/CMD style.\n    Args:\n        s: input str\n        platform: 'this' = auto from current platform; 1 = POSIX; 0 = Windows/CMD\n    Returns:\n        a list of splitting str\n    \"\"\"\n    if platform == 'this':\n        # Auto-detect current platform\n        import os\n        platform = 1 if os.name == 'posix' else 0\n    \n    if platform == 1:\n        # POSIX style\n        return s.split('/')\n    elif platform == 0:\n        # Windows/CMD style\n        return s.split('\\\\')\n    else:\n        raise ValueError(\"Invalid platform value. Use 'this', 1, or 0.\")\n\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def split(s, platform='this'):\\n\\t\\\"\\\"\\\"\\n\\tSplit the input str under given platform, return the splitting result\\n\\tIf platform equals 'this', auto-detect current platform.\\n\\tIf platform equals 1, use POSIX style.\\n\\tIf platform equals 0, use Windows/CMD style.\\n\\tArgs:\\n\\t    s: input str\\n\\t    platform: 'this' = auto from current platform; 1 = POSIX; 0 = Windows/CMD\\n\\tReturns:\\n\\t    a list of splitting str\\n\\t\\\"\\\"\\\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def split(s: str, platform: str = 'this') -> List[str]:\n    \"\"\"\n    Split the input str under given platform, return the splitting result\n    If platform equals 'this', auto-detect current platform.\n    If platform equals 1, use POSIX style.\n    If platform equals 0, use Windows/CMD style.\n    Args:\n        s: input str\n        platform: 'this' = auto from current platform; 1 = POSIX; 0 = Windows/CMD\n    Returns:\n        a list of splitting str\n    \"\"\"", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_27", "requirements": "", "code": "## main.py\n\ndef paging(response: list, max_results: int) -> None:\n    \"\"\"\n    Generator function that yields slices of the response list with a maximum length of max_results.\n\n    Args:\n        response (list): The list to be sliced.\n        max_results (int): The maximum number of elements in each slice.\n\n    Yields:\n        list: A slice of the response list.\n    \"\"\"\n    for i in range(0, len(response), max_results):\n        yield response[i:i + max_results]\n\n# Example usage\nif __name__ == \"__main__\":\n    response = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    max_results = 3\n    for page in paging(response, max_results):\n        print(page)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def paging(response, max_results):\n\t\"\n\tReturn every response with the length of max_results\n    Args:\n    response (list): WAPI response.\n    max_results (int): Maximum number of objects to be returned in one page.\n    Returns:\n        Generator object with WAPI response split page by page.\n\t\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `paging` takes two parameters: `response`, which is a list, and `max_results`, which is an integer. It returns a generator object that yields slices of the `response` list with a maximum length of `max_results`.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_34", "requirements": "", "code": "## main.py\n\ndef was_processed(processed: set[str], path_name: str, verbose: bool = False) -> bool:\n    \"\"\"\n    Checks if a given path has already been processed.\n\n    Args:\n        processed (set[str]): A set of strings representing processed paths.\n        path_name (str): The path to check.\n        verbose (bool, optional): Whether to enable verbose output. Defaults to False.\n\n    Returns:\n        bool: True if the path has been processed, False otherwise.\n    \"\"\"\n    if verbose:\n        print(f\"Checking if {path_name} has been processed...\")\n    \n    result = path_name in processed\n    \n    if verbose:\n        if result:\n            print(f\"{path_name} has been processed.\")\n        else:\n            print(f\"{path_name} has NOT been processed.\")\n    \n    return result\n\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def was_processed(processed, path_name, verbose):\n\t\"\n\tCheck if a file or directory has already been processed.\n\n\tTo prevent recursion, expand the path name to an absolution path\n\tcall this function with a set that will store all the entries and\n\tthe entry to test. If the entry is already in the set, report the issue\n\tand return ``True``. Otherwise, add the entry to the set and return\n\t``False`` to allow the path to be processed.\n\n\tArgs:\n\t\tprocessed: Set to store processed pathnames\n\t\tpath_name: Path to a directory or file\n\t\tverbose: True if verbose output is requested\n\n\tReturns:\n\t\tTrue if it's already in the set. False if not.\n\t\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `was_processed` takes three parameters: `processed` (a set of strings representing processed paths), `path_name` (a string representing the path to check), and `verbose` (a boolean indicating whether verbose output should be enabled). It returns a boolean value indicating whether the path has already been processed.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_59", "requirements": "", "code": "## main.py\n\nimport re\n\ndef get_pattern(pattern: str | re.Pattern, strip: bool = False) -> re.Pattern:\n    \"\"\"\n    Converts a string pattern or compiled regex pattern into a compiled regex pattern.\n    \n    Args:\n        pattern (str | re.Pattern): The pattern to compile. Can be a string or a compiled regex pattern.\n        strip (bool, optional): Whether to strip whitespace from the pattern string before compiling. Defaults to False.\n        \n    Returns:\n        re.Pattern: The compiled regex pattern.\n    \"\"\"\n    if isinstance(pattern, re.Pattern):\n        return pattern\n    \n    if strip:\n        pattern = pattern.strip()\n    \n    return re.compile(pattern)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Using a string pattern\n    pattern_str = r\"^\\d{3}-\\d{2}-\\d{4}$\"\n    compiled_pattern = get_pattern(pattern_str)\n    print(compiled_pattern)\n    \n    # Using a string pattern with stripping\n    pattern_str_with_strip = \" ^\\\\d{3}-\\\\d{2}-\\\\d{4} $ \"\n    compiled_pattern_with_strip = get_pattern(pattern_str_with_strip, strip=True)\n    print(compiled_pattern_with_strip)\n    \n    # Using a pre-compiled pattern\n    pre_compiled_pattern = re.compile(r\"^\\w+$\")\n    compiled_pattern_from_precompiled = get_pattern(pre_compiled_pattern)\n    print(compiled_pattern_from_precompiled)\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def get_pattern(pattern, strip=True):\n    \"\"\"Convert a string to a regex pattern object\n\n    Args:\n            pattern: str or regex pattern object\n            strip: boolean, whether the spaces in the start/end will be stripped\n    Returns:\n            regex pattern object\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `get_pattern` takes two parameters: `pattern` (str or re.Pattern) and `strip` (bool). It returns a re.Pattern object.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_15", "requirements": null, "code": null, "prd": null, "system_design": null, "task": null, "eval_result": true}
{"file_name": "CoderEval_41", "requirements": "", "code": "", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def get_repo_archive(url: str, destination_path: Path) -> Path:\\n    \\\"\\\"\\\"Given an url and a destination path, retrieve and extract .tar.gz archive which contains 'desc' file for each package\\n\\n        Args:\\n            url: url of the .tar.gz archive to download\\n            destination_path: the path on disk where to extract archive\\n        Returns:\\n                path where the archive is extracted to\\n    \\\"\\\"\\\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "def get_repo_archive(url: str, destination_path: Path) -> Path:", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_14", "requirements": "", "code": "## main.py\n\ndef is_valid(identifier: str) -> bool:\n    \"\"\"Check if the identifier is valid.\n\n    Args:\n        identifier (str): The identifier to check.\n\n    Returns:\n        bool: True if the identifier is valid, False otherwise.\n    \"\"\"\n    # Define the valid characters for the identifier\n    valid_chars = set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\")\n    \n    # Check if all characters in the identifier are valid\n    return all(char in valid_chars for char in identifier)\n\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def is_valid(self, identifier):\n\t\"\"\"\n\tReturn True if identifier is valid. In this base implementation, always return True.  (D)\n\t\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `is_valid` takes a single parameter `identifier` of type `str` and returns a boolean value `True`.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_13", "requirements": "", "code": "## main.py\n\ndef is_fill_compute_el(obj: object) -> bool:\n    \"\"\"Check if an object has both `fill` and `compute` methods.\n\n    Args:\n        obj (object): The object to check.\n\n    Returns:\n        bool: True if the object has both `fill` and `compute` methods, False otherwise.\n    \"\"\"\n    return hasattr(obj, 'fill') and hasattr(obj, 'compute')\n\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def is_fill_compute_el(obj):\n    \"\"\"Check whether the obj class has the fill and compute methods.\"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `is_fill_compute_el` takes one parameter:\n\n- `obj`: Any object (type: Any)\n\nIt returns a boolean value indicating whether the object has both `fill` and `compute` methods.", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "CoderEval_60", "requirements": "", "code": "## main.py\nfrom typing import List, Optional, Dict, Tuple\n\ndef run_command(commands: List[str], args: List[str], cwd: Optional[str] = None, verbose: bool = False, hide_stderr: bool = False, env: Optional[Dict[str, str]] = None) -> Tuple[str, int]:\n    \"\"\"\n    Executes a command with specified arguments and options.\n\n    Args:\n        commands (List[str]): The command to execute.\n        args (List[str]): Arguments for the command.\n        cwd (Optional[str], optional): Working directory for the command. Defaults to None.\n        verbose (bool, optional): Whether to print verbose output. Defaults to False.\n        hide_stderr (bool, optional): Whether to hide stderr output. Defaults to False.\n        env (Optional[Dict[str, str]], optional): Environment variables for the command. Defaults to None.\n\n    Returns:\n        Tuple[str, int]: A tuple containing stdout (str) and returncode (int).\n    \"\"\"\n    import subprocess\n\n    # Construct the full command\n    full_command = commands + args\n\n    # Prepare the environment\n    process_env = dict(env) if env else None\n\n    # Execute the command\n    try:\n        result = subprocess.run(\n            full_command,\n            cwd=cwd,\n            env=process_env,\n            capture_output=True,\n            text=True\n        )\n    except Exception as e:\n        error_message = f\"Error executing command: {e}\"\n        if verbose:\n            return error_message, 1\n        else:\n            return error_message, 1\n\n    # Handle verbose output\n    if verbose:\n        print(f\"Command executed: {' '.join(full_command)}\")\n        if not hide_stderr:\n            print(f\"Stderr: {result.stderr}\")\n\n    # Return stdout and returncode\n    return result.stdout, result.returncode\n", "prd": {"Language": "", "Programming Language": "", "Original Requirements": "def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n    \"\"\"A list of command is given. Run the given command(s) with the given arguments use a subprocess. Return the running result (stdout and returncode)\n    \"\"\"", "Project Name": "", "Product Goals": [], "User Stories": [], "Competitive Analysis": [], "Competitive Quadrant Chart": "", "Requirement Analysis": "", "Requirement Pool": [], "UI Design draft": "", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "", "File list": [], "Data structures and interfaces": "The function `run_command` takes the following parameters:\n- commands: List[str]\n- args: List[str]\n- cwd: Optional[str] = None\n- verbose: bool = False\n- hide_stderr: bool = False\n- env: Optional[Dict[str, str]] = None\nReturns a tuple containing stdout (str) and returncode (int).", "Program call flow": "", "Anything UNCLEAR": ""}, "task": {"Required packages": [], "Required Other language third-party packages": [], "Logic Analysis": [], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
