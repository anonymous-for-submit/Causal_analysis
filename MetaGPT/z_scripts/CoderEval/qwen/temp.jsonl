{"question_id": "62b8a7b2755ee91dce50a4a7", "input": "def default_tzinfo(dt, tzinfo):\n\t\"\"\"\n\tSets the ``tzinfo`` parameter on naive datetimes only\n\nThis is useful for example when you are provided a datetime that may have\neither an implicit or explicit time zone, such as when parsing a time zone\nstring.\n\n.. doctest::\n\n    >>> from dateutil.tz import tzoffset\n    >>> from dateutil.parser import parse\n    >>> from dateutil.utils import default_tzinfo\n    >>> dflt_tz = tzoffset(\"EST\", -18000)\n    >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n    2014-01-01 12:30:00+00:00\n    >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n    2014-01-01 12:30:00-05:00\n\n:param dt:\n    The datetime on which to replace the time zone\n\n:param tzinfo:\n    The :py:class:`datetime.tzinfo` subclass instance to assign to\n    ``dt`` if (and only if) it is naive.\n\n:return:\n    Returns an aware :py:class:`datetime.datetime`.\n\t\"\"\"\n\t", "signature": "def default_tzinfo(dt, tzinfo):", "docstring": "Sets the ``tzinfo`` parameter on naive datetimes only\n\nThis is useful for example when you are provided a datetime that may have\neither an implicit or explicit time zone, such as when parsing a time zone\nstring.\n\n.. doctest::\n\n    >>> from dateutil.tz import tzoffset\n    >>> from dateutil.parser import parse\n    >>> from dateutil.utils import default_tzinfo\n    >>> dflt_tz = tzoffset(\"EST\", -18000)\n    >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n    2014-01-01 12:30:00+00:00\n    >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n    2014-01-01 12:30:00-05:00\n\n:param dt:\n    The datetime on which to replace the time zone\n\n:param tzinfo:\n    The :py:class:`datetime.tzinfo` subclass instance to assign to\n    ``dt`` if (and only if) it is naive.\n\n:return:\n    Returns an aware :py:class:`datetime.datetime`.", "task_id": 62, "prompt": "def default_tzinfo(dt, tzinfo):\n\t\"\"\"\n\tSets the ``tzinfo`` parameter on naive datetimes only\n\nThis is useful for example when you are provided a datetime that may have\neither an implicit or explicit time zone, such as when parsing a time zone\nstring.\n\n.. doctest::\n\n    >>> from dateutil.tz import tzoffset\n    >>> from dateutil.parser import parse\n    >>> from dateutil.utils import default_tzinfo\n    >>> dflt_tz = tzoffset(\"EST\", -18000)\n    >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n    2014-01-01 12:30:00+00:00\n    >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n    2014-01-01 12:30:00-05:00\n\n:param dt:\n    The datetime on which to replace the time zone\n\n:param tzinfo:\n    The :py:class:`datetime.tzinfo` subclass instance to assign to\n    ``dt`` if (and only if) it is naive.\n\n:return:\n    Returns an aware :py:class:`datetime.datetime`.\n\t\"\"\"\n\t", "completions": ["from typing import List\n## main.py\n\nfrom datetime import datetime, timezone\nfrom dateutil import tz\n\ndef default_tzinfo(dt: datetime, tzinfo: timezone) -> datetime:\n    \"\"\"Set timezone information for a naive datetime object.\n\n    Args:\n        dt (datetime): The datetime object to check and modify.\n        tzinfo (timezone): The timezone information to set.\n\n    Returns:\n        datetime: The datetime object with timezone information set.\n    \"\"\"\n    # Check if the datetime object is naive\n    if dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None:\n        # Set the timezone information\n        return dt.replace(tzinfo=tzinfo)\n    else:\n        # Return the original datetime object if it's already aware\n        return dt\n\ndef convert_to_utc(dt: datetime, source_tz_str: str) -> datetime:\n    \"\"\"Convert a datetime object from a specified timezone to UTC.\n\n    Args:\n        dt (datetime): The datetime object to convert.\n        source_tz_str (str): The source timezone string.\n\n    Returns:\n        datetime: The datetime object converted to UTC.\n\n    Raises:\n        ValueError: If the timezone string cannot be parsed.\n    \"\"\"\n    try:\n        # Parse the source timezone string\n        source_tz = tz.gettz(source_tz_str)\n        \n        # Localize the datetime object to the source timezone\n        localized_dt = dt.replace(tzinfo=source_tz)\n        \n        # Convert to UTC\n        utc_dt = localized_dt.astimezone(timezone.utc)\n        \n        return utc_dt\n    except Exception as e:\n        raise ValueError(f\"Failed to parse timezone string '{source_tz_str}': {e}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    naive_dt = datetime(2023, 10, 1, 12, 0, 0)\n    tzinfo_example = timezone.utc\n    \n    # Set timezone information\n    aware_dt = default_tzinfo(naive_dt, tzinfo_example)\n    print(f\"Naive datetime: {naive_dt}\")\n    print(f\"Aware datetime: {aware_dt}\")\n    \n    # Convert to UTC\n    source_tz_str = \"America/New_York\"\n    utc_dt = convert_to_utc(aware_dt, source_tz_str)\n    print(f\"UTC datetime: {utc_dt}\")\n"], "pass": true, "pass_num": 1}
