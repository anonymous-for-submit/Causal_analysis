{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Requirement Pool,design_Program call flow,task_File list", "requirements": "No required packages", "code": "## test.py\nfrom typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean_value = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                temp_sum = total_sum - arr[i] - arr[j]\n                if temp_sum / (n - 2) == mean_value:\n                    pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Performance and Scalability\"\n    x-axis \"Low Performance\" --> \"High Performance\"\n    y-axis \"Low Scalability\" --> \"High Scalability\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Brute Force Approach\": [0.2, 0.3]\n    \"Optimized Solution\": [0.7, 0.8]\n    \"Advanced Mathematical Techniques\": [0.4, 0.5]\n    \"Efficient Data Structures\": [0.6, 0.7]\n    \"Parallel Processing\": [0.5, 0.6]\n    \"Memory Optimization\": [0.3, 0.4]\n    \"Error Handling\": [0.1, 0.2]\n    \"Our Target Product\": [0.8, 0.9]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to check for non-prime numbers."], ["P1", "Optimize the function for performance with large inputs."], ["P2", "Provide unit tests to ensure accuracy of the function."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python's built-in data structures and libraries. The key steps include calculating the mean of the array, iterating through all possible pairs of elements, and counting the valid pairs that, when removed, result in the same mean. We will use a brute-force approach to ensure simplicity and correctness, given the constraints.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["test.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,design_Program call flow,task_File list", "requirements": "No required packages", "code": "## test.py\nfrom typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_to_delete = 0\n    count = {}\n    \n    for num in arr:\n        diff = num - mean\n        if diff in count:\n            pairs_to_delete += count[diff]\n            count[diff] += 1\n        else:\n            count[diff] = 1\n    \n    return pairs_to_delete\n\n# Interface using input() and print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its simplicity and the availability of powerful libraries. We will calculate the mean of the array once and then iterate through the array to find pairs of elements that, when removed, result in the same mean. This approach will be optimized to handle large inputs by avoiding unnecessary computations.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["test.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Programming Language,prd_Product Goals,prd_Requirement Analysis", "requirements": "No required packages", "code": "## main.py\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    result = []\n    array = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            x = int(parts[1])\n            array.append(x)\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            # Use a list comprehension to update the array in a more efficient manner\n            array = [y if elem == x else elem for elem in array]\n    \n    return array\n\n# Read input from stdin\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Java", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a player, I want to be able to choose difficulty levels", "As a player, I want to see my score after each game", "As a player, I want to get restart button when I lose", "As a player, I want to see beautiful UI that make me feel good", "As a player, I want to play game via mobile phone"], "Competitive Analysis": ["2048 Game A: Simple interface, lacks responsive features", "play2048.co: Beautiful and responsive UI with my best score shown", "2048game.com: Responsive UI with my best score shown, but many ads"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The function should efficiently determine non-prime numbers, ideally using a method that minimizes computational complexity. It should handle edge cases such as negative numbers and zero.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "A simple interface with a clear input area for queries and a display area for the resulting array. The design should be clean and intuitive, with buttons for each type of query operation.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To implement the described functionality in Python, we will use a list to represent the array of integers. For each query, we will handle the addition of an element or the replacement of all occurrences of a specific element with another. We will ensure efficiency by avoiding unnecessary operations, especially when handling large numbers of queries.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef func(queries: List[str])->List[int]:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input number of queries (q)\n    P->>P: Initialize an empty list\n    loop For each query\n        U->>P: Input a query\n        P->>P: Parse the query\n        P->>P: Execute the query\n        P->>P: Update the list\n    end\n    P->>U: Output the resulting list\n", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "openapi: 3.0.0 ...", "Shared Knowledge": "", "Anything UNCLEAR": "Clarification needed on how to start and initialize third-party libraries."}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Programming Language,prd_Product Goals,prd_User Stories", "requirements": "No required packages", "code": "## main.py\n\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    array = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            # Query type 1: Add element to the array\n            element = int(parts[1])\n            array.append(element)\n        elif parts[0] == '2':\n            # Query type 2: Replace all occurrences of x with y\n            x = int(parts[1])\n            y = int(parts[2])\n            for i in range(len(array)):\n                if array[i] == x:\n                    array[i] = y\n    \n    return array\n\n# Interface using input() and print()\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Java", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a user, I want to input a number and receive a response indicating if it is non-prime", "As a user, I want to check a list of numbers for non-primality", "As a user, I want to understand the logic behind the non-prime identification"], "Competitive Analysis": ["2048 Game A: Simple interface, lacks responsive features", "play2048.co: Beautiful and responsive UI with my best score shown", "2048game.com: Responsive UI with my best score shown, but many ads"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The requirements involve managing an array and performing two types of operations on it: adding an element and replacing occurrences of a specific element with another. The operations are straightforward and do not require complex data structures or algorithms. The constraints are high, with the possibility of up to 5 * 10^5 queries, which means the solution should be efficient to handle such a large number of operations.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "A simple interface with a clear input area for queries and a display area for the resulting array. The design should be clean and intuitive, with buttons for each type of query operation.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To implement the solution efficiently for handling up to 5 * 10^5 queries, we will use Python's built-in list data structure for managing the array. For each query, we will perform the corresponding operation based on the query type. For query type 1, we will append the element to the array. For query type 2, we will replace all occurrences of the specified element with another. The solution will be designed to be user-friendly, providing clear documentation and a simple interface for easy interaction.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef func(queries: List[str])->List[int]:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input number of queries (q)\n    P->>U: Request input for each query\n    loop For each query\n        U->>P: Input query\n        P->>P: Parse query type and parameters\n        alt Query type 1\n            P->>P: Add element to array\n        else Query type 2\n            P->>P: Replace occurrences of element\n        end\n    end\n    P->>U: Output resulting array\n", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type."}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "openapi: 3.0.0 ...", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Requirement Pool,design_Program call flow,task_Full API spec", "requirements": "No required packages", "code": "from typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Performance and Scalability\"\n    x-axis \"Low Performance\" --> \"High Performance\"\n    y-axis \"Low Scalability\" --> \"High Scalability\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Brute Force Approach\": [0.2, 0.3]\n    \"Optimized Solution\": [0.7, 0.8]\n    \"Advanced Mathematical Techniques\": [0.4, 0.5]\n    \"Efficient Data Structures\": [0.6, 0.7]\n    \"Parallel Processing\": [0.5, 0.6]\n    \"Memory Optimization\": [0.3, 0.4]\n    \"Error Handling\": [0.1, 0.2]\n    \"Our Target Product\": [0.8, 0.9]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to check for non-prime numbers."], ["P1", "Optimize the function for performance with large inputs."], ["P2", "Provide unit tests to ensure accuracy of the function."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the array operations. We will calculate the mean of the array and then iterate through the array to find pairs of elements that, when removed, result in the same mean. This approach will be optimized to handle large inputs efficiently.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Programming Language,prd_Product Goals,prd_Competitive Analysis", "requirements": "No required packages", "code": "## main.py\n\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    array = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            x = int(parts[1])\n            array.append(x)\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            # Use a temporary list to collect the new values\n            new_array = [y if elem == x else elem for elem in array]\n            array = new_array\n        else:\n            raise ValueError(\"Invalid query type\")\n    \n    return array\n\n# Read input from stdin\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\n\n# Call the function and print the result\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Java", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a player, I want to be able to choose difficulty levels", "As a player, I want to see my score after each game", "As a player, I want to get restart button when I lose", "As a player, I want to see beautiful UI that make me feel good", "As a player, I want to play game via mobile phone"], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The requirements involve managing an array and performing two types of operations on it: adding an element and replacing occurrences of a specific element with another. The operations are straightforward and do not require complex data structures or algorithms. The constraints are high, with the possibility of up to 5 * 10^5 queries, which means the solution should be efficient to handle such a large number of operations.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "A simple interface with a clear input area for queries and a display area for the resulting array. The design should be clean and intuitive, with buttons for each type of query operation.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To implement the solution efficiently for handling up to 5 * 10^5 queries, we will use a Python list to represent the array and perform operations directly on it. For the second type of query, we will use the `list.replace()` method to replace all occurrences of a specific element with another. The solution will be simple and efficient, leveraging Python's built-in data structures and methods.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef func(queries: List[str])->List[int]:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input number of queries (q)\n    P->>P: Initialize an empty list to store the array\n    loop for each query\n        U->>P: Input a query\n        P->>P: Parse the query to determine its type and parameters\n        alt if query is of type '1 x'\n            P->>P: Add element x to the end of the array\n        else if query is of type '2 x y'\n            P->>P: Replace all occurrences of x with y in the array\n        end\n    end\n    P->>U: Print the resulting array as space-separated integers\n", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type."}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "openapi: 3.0.0 ...", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Quadrant Chart,design_Program call flow,task_File list", "requirements": "No required packages", "code": "from typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == mean:\n                pairs += 1\n    return pairs\n\n# Read input and output results\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["Simple solution with brute force approach", "Optimized solution with better time complexity", "Solution using advanced mathematical techniques", "Solution with efficient use of data structures", "Solution with parallel processing", "Solution with memory optimization", "Solution with error handling"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "We will use Python to solve this problem. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. To optimize the solution for large inputs, we will use efficient data structures and avoid unnecessary computations.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["test.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,design_Program call flow,task_Anything UNCLEAR", "requirements": "No required packages", "code": "## main.py\nfrom typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_count = 0\n    \n    # Create a dictionary to count occurrences of each difference\n    diff_count = {}\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                new_sum = total_sum - arr[i] - arr[j]\n                new_mean = new_sum / (n - 2)\n                if new_mean == mean:\n                    # Use a tuple (i, j) as the key since it's hashable and can be used as a dictionary key\n                    pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard library and the ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will optimize this by ensuring that we only consider pairs that are distinct and avoid redundant calculations.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": "Clarification needed on whether the function should handle only integers or also floating-point numbers."}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,design_Program call flow,task_Shared Knowledge", "requirements": "No required packages", "code": "from typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == mean:\n                pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Interface using input() and print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard library and the ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will use a brute-force method to ensure simplicity and correctness, but we will optimize it by avoiding unnecessary calculations and leveraging Python's efficient data structures.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Product Goals,prd_User Stories,prd_UI Design draft", "requirements": "No required packages", "code": "from typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    result = []\n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            result.append(int(parts[1]))\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            result = [y if num == x else num for num in result]\n    return result\n\n# Read input from stdin\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Python", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a user, I want to input a number and receive a response indicating if it is non-prime", "As a user, I want to check a list of numbers for non-primality", "As a user, I want to understand the logic behind the non-prime identification"], "Competitive Analysis": ["2048 Game A: Simple interface, lacks responsive features", "play2048.co: Beautiful and responsive UI with my best score shown", "2048game.com: Responsive UI with my best score shown, but many ads"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The requirements involve managing an array and performing two types of operations on it: adding an element and replacing occurrences of a specific element with another. The operations are straightforward and do not require complex data structures or algorithms. The constraints are high, with the possibility of up to 5 * 10^5 queries, which means the solution should be efficient to handle such a large number of operations.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "The function will be a simple command-line interface where users can input numbers and receive immediate feedback on their primality status.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To implement the solution, we will use a simple and efficient approach using a Python list to manage the array of integers. For each query, we will handle the operations as specified. The list will be dynamically updated based on the queries. We will ensure that the solution is efficient by avoiding unnecessary operations and leveraging Python's built-in list methods.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef func(queries: List[str]) -> List[int]:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input number of queries (q)\n    P->>P: Initialize an empty list to store the array\n    loop For each query\n        U->>P: Input a query\n        P->>P: Parse the query to determine the type and parameters\n        alt If the query is of type '1'\n            P->>P: Add the element to the end of the array\n        else If the query is of type '2'\n            P->>P: Replace all occurrences of x with y in the array\n        end\n    end\n    P->>U: Output the resulting array\n", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "openapi: 3.0.0 ...", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,prd_UI Design draft,design_Program call flow", "requirements": "No required packages", "code": "from typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == mean:\n                pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "The function will be a simple command-line interface where users can input numbers and receive immediate feedback on their primality status.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the array operations and pair-wise comparisons. We will calculate the mean of the array once and then iterate through the array to find pairs of elements that, when removed, result in the same mean. This approach will be optimized to handle large inputs by leveraging Python's efficient list operations and avoiding unnecessary computations.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Programming Language,prd_Product Goals,prd_UI Design draft", "requirements": "No required packages", "code": "from typing import List\n\ndef func(queries: List[List[int]]) -> List[int]:\n    result = []\n    array = []\n    \n    for query in queries:\n        if query[0] == 1:\n            array.append(query[1])\n        elif query[0] == 2:\n            x, y = query[1], query[2]\n            array = [y if elem == x else elem for elem in array]\n    \n    return array\n\n# Read input from stdin\nq = int(input())\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\n# Call the function and print the result\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Java", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a player, I want to be able to choose difficulty levels", "As a player, I want to see my score after each game", "As a player, I want to get restart button when I lose", "As a player, I want to see beautiful UI that make me feel good", "As a player, I want to play game via mobile phone"], "Competitive Analysis": ["2048 Game A: Simple interface, lacks responsive features", "play2048.co: Beautiful and responsive UI with my best score shown", "2048game.com: Responsive UI with my best score shown, but many ads"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The requirements involve managing an array and performing two types of operations on it: adding an element and replacing occurrences of a specific element with another. The operations are straightforward and do not require complex data structures or algorithms. The constraints are high, with the possibility of up to 5 * 10^5 queries, which means the solution should be efficient to handle such a large number of operations.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "The function will be a simple command-line interface where users can input numbers and receive immediate feedback on their primality status.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To implement the solution efficiently for handling up to 5 * 10^5 queries, we will use a Python list to store the array elements. For the query operations, we will handle them sequentially. For the '1 x' query, we will append 'x' to the list. For the '2 x y' query, we will replace all occurrences of 'x' with 'y' in the list. Since the constraints allow for up to 5 * 10^5 queries, we need to ensure our solution is optimized for performance. We will avoid using Python's built-in list.remove() and list.replace() methods, which are not efficient for large lists, and instead iterate through the list to perform the replacements.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef func(queries: List[List[int]])->List[int]:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nqueries = [list(map(int, input().split())) for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "Program call flow": "", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Programming Language,prd_Product Goals,prd_Anything UNCLEAR", "requirements": "No required packages", "code": "## main.py\nfrom typing import List\nfrom collections import defaultdict\n\ndef func(queries: List[str]) -> List[int]:\n    result_list = []\n    replacement_map = defaultdict(int)\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            x = int(parts[1])\n            result_list.append(x)\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            for i in range(len(result_list)):\n                if result_list[i] == x:\n                    result_list[i] = y\n    \n    return result_list\n\n# Read input from stdin\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Java", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a player, I want to be able to choose difficulty levels", "As a player, I want to see my score after each game", "As a player, I want to get restart button when I lose", "As a player, I want to see beautiful UI that make me feel good", "As a player, I want to play game via mobile phone"], "Competitive Analysis": ["2048 Game A: Simple interface, lacks responsive features", "play2048.co: Beautiful and responsive UI with my best score shown", "2048game.com: Responsive UI with my best score shown, but many ads"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The requirements involve managing an array and performing two types of operations on it: adding an element and replacing occurrences of a specific element with another. The operations are straightforward and do not require complex data structures or algorithms. The constraints are high, with the possibility of up to 5 * 10^5 queries, which means the solution should be efficient to handle such a large number of operations.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "A simple interface with a clear input area for queries and a display area for the resulting array. The design should be clean and intuitive, with buttons for each type of query operation.", "Anything UNCLEAR": "Clarification on whether the function should handle only integers or also floating-point numbers."}, "system_design": {"Implementation approach": "To implement the solution efficiently for handling up to 5 * 10^5 queries, we will use Python's built-in list data structure for managing the array. For each query of type '1', we will append the element to the array. For each query of type '2', we will replace all occurrences of the specified element with another. Given the constraints, we need to ensure that the solution is optimized for performance, especially considering the upper limit of queries.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef func(queries: List[str])->List[int]:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input number of queries (q)\n    P->>P: Initialize an empty list\n    loop For each query\n        U->>P: Input a query\n        P->>P: Parse the query\n        alt Query type '1'\n            U->>P: Input element to add\n            P->>P: Append element to the list\n        else Query type '2'\n            U->>P: Input element to replace (x) and new element (y)\n            P->>P: Replace all occurrences of x with y in the list\n        end\n    end\n    P->>U: Output the resulting list\n", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type."}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Requirement Pool,design_Program call flow,task_Required Other language third-party packages", "requirements": "No required packages", "code": "from typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean_value = total_sum / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if i != j:\n                temp_sum = total_sum - arr[i] - arr[j]\n                if temp_sum / (n - 2) == mean_value:\n                    pairs_count += 1\n    \n    return pairs_count\n\n# Interface using input() and print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Performance and Scalability\"\n    x-axis \"Low Performance\" --> \"High Performance\"\n    y-axis \"Low Scalability\" --> \"High Scalability\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Brute Force Approach\": [0.2, 0.3]\n    \"Optimized Solution\": [0.7, 0.8]\n    \"Advanced Mathematical Techniques\": [0.4, 0.5]\n    \"Efficient Data Structures\": [0.6, 0.7]\n    \"Parallel Processing\": [0.5, 0.6]\n    \"Memory Optimization\": [0.3, 0.4]\n    \"Error Handling\": [0.1, 0.2]\n    \"Our Target Product\": [0.8, 0.9]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to check for non-prime numbers."], ["P1", "Optimize the function for performance with large inputs."], ["P2", "Provide unit tests to ensure accuracy of the function."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the array operations. The key steps include calculating the mean of the array, iterating through possible pairs of elements to delete, and counting the valid pairs that result in the same mean. We will use a brute-force approach initially to ensure correctness and then optimize it based on performance testing.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["These are the required third-party packages: x,y,z"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Programming Language,prd_Product Goals,design_Implementation approach", "requirements": "No required packages", "code": "## main.py\n\nfrom typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    result = []\n    array = []\n\n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            x = int(parts[1])\n            array.append(x)\n        elif parts[0] == '2':\n            x, y = int(parts[1]), int(parts[2])\n            if x in array:\n                array = [y if elem == x else elem for elem in array]\n\n    return array\n\n# Read input from stdin\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Java", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a player, I want to be able to choose difficulty levels", "As a player, I want to see my score after each game", "As a player, I want to get restart button when I lose", "As a player, I want to see beautiful UI that make me feel good", "As a player, I want to play game via mobile phone"], "Competitive Analysis": ["2048 Game A: Simple interface, lacks responsive features", "play2048.co: Beautiful and responsive UI with my best score shown", "2048game.com: Responsive UI with my best score shown, but many ads"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The requirements involve managing an array and performing two types of operations on it: adding an element and replacing occurrences of a specific element with another. The operations are straightforward and do not require complex data structures or algorithms. The constraints are high, with the possibility of up to 5 * 10^5 queries, which means the solution should be efficient to handle such a large number of operations.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "A simple interface with a clear input area for queries and a display area for the resulting array. The design should be clean and intuitive, with buttons for each type of query operation.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "We will implement a simple function to identify non-prime numbers using basic mathematical checks. The function will handle edge cases such as negative numbers and zero, and will be optimized for performance to handle large inputs efficiently. We will use the built-in Python capabilities without relying on heavy external libraries, ensuring simplicity and reliability.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef func(queries: List[str])->List[int]:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nqueries = [input() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input number of queries (q)\n    P->>P: Initialize an empty list\n    loop For each query\n        U->>P: Input a query\n        P->>P: Parse the query\n        alt Query type 1\n            U->>P: Input element to add\n            P->>P: Append element to the list\n        else Query type 2\n            U->>P: Input element to replace (x) and new element (y)\n            P->>P: Replace all occurrences of x with y in the list\n        end\n    end\n    P->>U: Output the resulting list\n", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type."}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Product Goals,prd_User Stories,prd_Competitive Analysis", "requirements": "No required packages", "code": "## main.py\nfrom builtins import input\n\ndef process_queries(q: int) -> list:\n    array = []\n    \n    for _ in range(q):\n        query = input().split()\n        \n        if query[0] == '1':\n            x = int(query[1])\n            array.append(x)\n        elif query[0] == '2':\n            x = int(query[1])\n            y = int(query[2])\n            # Use a more efficient approach to replace elements\n            array = [y if elem == x else elem for elem in array]\n    \n    return array\n\n# Read the number of queries\nq = int(input())\nresult = process_queries(q)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Python", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a user, I want to input a number and receive a response indicating if it is non-prime", "As a user, I want to check a list of numbers for non-primality", "As a user, I want to understand the logic behind the non-prime identification"], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The requirements involve managing an array and performing two types of operations on it: adding an element and replacing occurrences of a specific element with another. The operations are straightforward and do not require complex data structures or algorithms. The constraints are high, with the possibility of up to 5 * 10^5 queries, which means the solution should be efficient to handle such a large number of operations.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "A simple interface with a clear input area for queries and a display area for the resulting array. The design should be clean and intuitive, with buttons for each type of query operation.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To implement the requirements, we will use a simple and efficient approach using Python's built-in data structures and standard library functions. We will maintain a list to represent the array and use list methods to perform the required operations efficiently.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef process_queries(q: int) -> list:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nresult = process_queries(q)\nprint(' '.join(map(str, result)))\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input number of queries (q)\n    P->>P: Initialize an empty list to store the array\n    loop For each query\n        U->>P: Input query type and parameters\n        P->>P: Process the query based on its type\n        Note right of P: Query types:\n        Note right of P: 1 x - Add element x to the array\n        Note right of P: 2 x y - Replace all occurrences of x with y in the array\n        P->>P: Perform the query operation\n    end\n    P->>U: Output the resulting array as space-separated integers\n", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Requirement Pool,design_Program call flow,task_Logic Analysis", "requirements": "No required packages", "code": "from typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Interface using input() and print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Performance and Scalability\"\n    x-axis \"Low Performance\" --> \"High Performance\"\n    y-axis \"Low Scalability\" --> \"High Scalability\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Brute Force Approach\": [0.2, 0.3]\n    \"Optimized Solution\": [0.7, 0.8]\n    \"Advanced Mathematical Techniques\": [0.4, 0.5]\n    \"Efficient Data Structures\": [0.6, 0.7]\n    \"Parallel Processing\": [0.5, 0.6]\n    \"Memory Optimization\": [0.3, 0.4]\n    \"Error Handling\": [0.1, 0.2]\n    \"Our Target Product\": [0.8, 0.9]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to check for non-prime numbers."], ["P1", "Optimize the function for performance with large inputs."], ["P2", "Provide unit tests to ensure accuracy of the function."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the array operations. We will calculate the mean of the array and then iterate through the array to find pairs of elements that, when removed, result in the same mean. This approach will be optimized to handle large inputs efficiently.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["test.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,design_Program call flow,task_File list", "requirements": "No required packages", "code": "## test.py\nfrom typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_count = n - 2\n            new_mean = new_sum / new_count\n            \n            if new_mean == mean:\n                pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Interface using input() and print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Performance and Scalability\"\n    x-axis \"Low Performance\" --> \"High Performance\"\n    y-axis \"Low Scalability\" --> \"High Scalability\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Brute Force Approach\": [0.2, 0.3]\n    \"Optimized Solution\": [0.7, 0.8]\n    \"Advanced Mathematical Techniques\": [0.4, 0.5]\n    \"Efficient Data Structures\": [0.6, 0.7]\n    \"Parallel Processing\": [0.5, 0.6]\n    \"Memory Optimization\": [0.3, 0.4]\n    \"Error Handling\": [0.1, 0.2]\n    \"Our Target Product\": [0.8, 0.9]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "We will use Python to solve this problem. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. To optimize the solution for large inputs, we will use efficient data structures and avoid unnecessary computations.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["test.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Product Goals,prd_User Stories,prd_Requirement Analysis", "requirements": "No required packages", "code": "from typing import List\n\ndef func(q: int, queries: List[List[str]]) -> List[int]:\n    result = []\n    array = []\n    \n    for query in queries:\n        if query[0] == '1':\n            x = int(query[1])\n            array.append(x)\n        elif query[0] == '2':\n            x = int(query[1])\n            y = int(query[2])\n            array = [y if elem == x else elem for elem in array]\n    \n    return array\n\n# Read input from stdin\nq = int(input())\nqueries = [input().split() for _ in range(q)]\nresult = func(q, queries)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Python", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a user, I want to input a number and receive a response indicating if it is non-prime", "As a user, I want to check a list of numbers for non-primality", "As a user, I want to understand the logic behind the non-prime identification"], "Competitive Analysis": ["2048 Game A: Simple interface, lacks responsive features", "play2048.co: Beautiful and responsive UI with my best score shown", "2048game.com: Responsive UI with my best score shown, but many ads"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The function should efficiently determine non-prime numbers, ideally using a method that minimizes computational complexity. It should handle edge cases such as negative numbers and zero.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "A simple interface with a clear input area for queries and a display area for the resulting array. The design should be clean and intuitive, with buttons for each type of query operation.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To efficiently handle the given queries, we will use a Python list to simulate the array and manage the operations accordingly. We will iterate through each query, applying the necessary operations based on the query type. For query type 2, we will use a simple list comprehension to replace all occurrences of x with y.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef func(q: int, queries: List[List[str]]) -> List[int]:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nqueries = [input().split() for _ in range(q)]\nresult = func(q, queries)\nprint(' '.join(map(str, result)))\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input q\n    U->>P: Input queries\n    P->>P: Initialize an empty list\n    P->>P: Iterate through each query\n    P->>P: If query type is '1', append the element to the list\n    P->>P: If query type is '2', replace all occurrences of x with y using list comprehension\n    P->>U: Output the resulting list\n", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "openapi: 3.0.0 ...", "Shared Knowledge": "", "Anything UNCLEAR": "Clarification needed on how to start and initialize third-party libraries."}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,task_File list", "requirements": "No required packages", "code": "## test.py\nfrom typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            temp_sum = total_sum - arr[i] - arr[j]\n            if temp_sum / (n - 2) == mean:\n                pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Interface using input() and print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard libraries and ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will use a brute-force method initially to ensure correctness and then optimize it for better performance.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input t (number of test cases)\n    P->>P: Initialize result counter\n    loop For each test case\n        P->>U: Input n (number of elements in array)\n        P->>U: Input array elements\n        P->>P: Calculate mean of the array\n        P->>P: Initialize pairs counter\n        loop For each pair of elements\n            P->>P: Check if removing the pair results in the same mean\n            P->>P: Increment pairs counter if condition met\n        end\n        P->>U: Output pairs counter\n    end\n", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["test.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Requirement Pool,design_Program call flow,task_Required packages", "requirements": "required packages are a,b,c,d,e,f,g", "code": "from typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Performance and Scalability\"\n    x-axis \"Low Performance\" --> \"High Performance\"\n    y-axis \"Low Scalability\" --> \"High Scalability\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Brute Force Approach\": [0.2, 0.3]\n    \"Optimized Solution\": [0.7, 0.8]\n    \"Advanced Mathematical Techniques\": [0.4, 0.5]\n    \"Efficient Data Structures\": [0.6, 0.7]\n    \"Parallel Processing\": [0.5, 0.6]\n    \"Memory Optimization\": [0.3, 0.4]\n    \"Error Handling\": [0.1, 0.2]\n    \"Our Target Product\": [0.8, 0.9]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to check for non-prime numbers."], ["P1", "Optimize the function for performance with large inputs."], ["P2", "Provide unit tests to ensure accuracy of the function."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the array operations. We will calculate the mean of the array and then iterate through the array to find pairs of elements that, when removed, result in the same mean. This approach will be optimized to handle large inputs efficiently.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["required packages are a,b,c,d,e,f,g"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_151_no_prd_Language,prd_Product Goals,prd_User Stories,prd_Anything UNCLEAR", "requirements": "No required packages", "code": "from typing import List\n\ndef func(queries: List[str]) -> List[int]:\n    result_list = []\n    \n    for query in queries:\n        parts = query.split()\n        if parts[0] == '1':\n            result_list.append(int(parts[1]))\n        elif parts[0] == '2':\n            x = int(parts[1])\n            y = int(parts[2])\n            result_list = [y if elem == x else elem for elem in result_list]\n    \n    return result_list\n\n# Read input from stdin\nq = int(input().strip())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "prd": {"Language": "chinese", "Programming Language": "Python", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type.\n\nExamples\n\nInput\n\n7\n1 3\n1 1\n2 1 2\n1 2\n1 1\n1 2\n2 1 3\n\nOutput\n\n3 2 2 3 2\n\nInput\n\n4\n1 1\n1 2\n1 1\n2 2 2\n\nOutput\n\n1 2 1\n\nInput\n\n8\n2 1 4\n1 1\n1 4\n1 2\n2 2 4\n2 4 3\n1 2\n2 2 7\n\nOutput\n\n1 3 3 7\n\nNote\n\nIn the first example, the array changes as follows:\n\n[] → [3] → [3, 1] → [3, 2] → [3, 2, 2] → [3, 2, 2, 1] → [3, 2, 2, 1, 2] → [3, 2, 2, 3, 2].\n\nIn the second example, the array changes as follows:\n\n[] → [1] → [1, 2] → [1, 2, 1] → [1, 2, 1].\n\nIn the third example, the array changes as follows:\n\n[] → [] → [1] → [1, 4] → [1, 4, 2] → [1, 4, 4] → [1, 3, 3] → [1, 3, 3, 2] → [1, 3, 3, 7].\n", "Project Name": "", "Product Goals": ["Create a reliable function for identifying non-prime numbers", "Ensure the function is efficient and handles large inputs", "Provide clear documentation for users"], "User Stories": ["As a user, I want to input a number and receive a response indicating if it is non-prime", "As a user, I want to check a list of numbers for non-primality", "As a user, I want to understand the logic behind the non-prime identification"], "Competitive Analysis": ["2048 Game A: Simple interface, lacks responsive features", "play2048.co: Beautiful and responsive UI with my best score shown", "2048game.com: Responsive UI with my best score shown, but many ads"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Campaign A\": [0.3, 0.6]\n    \"Campaign B\": [0.45, 0.23]\n    \"Campaign C\": [0.57, 0.69]\n    \"Campaign D\": [0.78, 0.34]\n    \"Campaign E\": [0.40, 0.34]\n    \"Campaign F\": [0.35, 0.78]\n    \"Our Target Product\": [0.5, 0.6]", "Requirement Analysis": "The requirements involve managing an array and performing two types of operations on it: adding an element and replacing occurrences of a specific element with another. The operations are straightforward and do not require complex data structures or algorithms. The constraints are high, with the possibility of up to 5 * 10^5 queries, which means the solution should be efficient to handle such a large number of operations.", "Requirement Pool": [["P0", "Implement the ability to add elements to the array."], ["P0", "Implement the ability to replace all occurrences of a specific element with another."], ["P1", "Ensure the solution is efficient to handle up to 5 * 10^5 queries."], ["P2", "Design a user-friendly interface for easy interaction."]], "UI Design draft": "A simple interface with a clear input area for queries and a display area for the resulting array. The design should be clean and intuitive, with buttons for each type of query operation.", "Anything UNCLEAR": "Clarification on whether the function should handle only integers or also floating-point numbers."}, "system_design": {"Implementation approach": "To implement the solution, we will use a simple and efficient approach using a Python list to store the array of integers. For each query, we will handle the operations as specified. The list will be dynamically updated based on the queries. We will ensure that the solution is efficient by avoiding unnecessary operations and leveraging Python's built-in list methods.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef func(queries: List[str])->List[int]:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nq = int(input())\nqueries = [input().strip() for _ in range(q)]\nresult = func(queries)\nprint(' '.join(map(str, result)))\n", "Program call flow": "sequenceDiagram\n    participant U as User\n    participant P as Program\n    U->>P: Input number of queries (q)\n    P->>P: Initialize an empty list to store the array\n    loop For each query\n        U->>P: Input a query\n        P->>P: Parse the query to determine the type and parameters\n        alt If the query is of type '1 x'\n            P->>P: Add element x to the end of the array\n        else If the query is of type '2 x y'\n            P->>P: Replace all occurrences of x with y in the array\n        end\n    end\n    P->>U: Output the resulting array as a space-separated string\n", "Original Requirements": "You have an array of integers (initially empty). You have to perform q queries. Each query is of one of two types:\n\n  * \"1 x\" — add the element x to the end of the array;\n  * \"2 x y\" — replace all occurrences of x in the array with y.\n\nInput\n\nThe first line contains a single integer q (1 ≤ q ≤ 5 ⋅ 10^5) — the number of queries. Next q lines contain queries (one per line). Each query is of one of two types:\n\n  * \"1 x\" (1 ≤ x ≤ 5 ⋅ 10^5);\n  * \"2 x y\" (1 ≤ x, y ≤ 5 ⋅ 10^5).\n\nIt's guaranteed that there is at least one query of the first type.\n\nOutput\n\nIn a single line, print k integers — the resulting array after performing all the queries, where k is the number of queries of the first type."}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "openapi: 3.0.0 ...", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,design_Program call flow,task_Logic Analysis", "requirements": "No required packages", "code": "from typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == mean:\n                pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Interface using input() and print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard library and the ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will optimize this by ensuring that we only consider pairs that are distinct and avoid redundant calculations.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["test.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,design_Program call flow,task_Required Other language third-party packages", "requirements": "No required packages", "code": "from typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                pairs += 1\n    return pairs\n\n# Read input and output results\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard library and the ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will use a brute-force method to ensure simplicity and correctness, and we will optimize it by using efficient data structures and avoiding redundant calculations.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["These are the required third-party packages: x,y,z"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,design_Program call flow", "requirements": "No required packages", "code": "## main.py\nfrom typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) / (n - 2) == mean:\n                count += 1\n    return count\n\n# Read input and process each test case\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard library and the ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will optimize this by avoiding recalculating the mean for each pair and instead use a more efficient method to count the pairs.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Requirement Pool,design_File list,design_Program call flow", "requirements": "No required packages", "code": "from typing import List\n\ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                pairs_count += 1\n    \n    return pairs_count\n\n# Interface using input() and print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Performance and Scalability\"\n    x-axis \"Low Performance\" --> \"High Performance\"\n    y-axis \"Low Scalability\" --> \"High Scalability\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Brute Force Approach\": [0.2, 0.3]\n    \"Optimized Solution\": [0.7, 0.8]\n    \"Advanced Mathematical Techniques\": [0.4, 0.5]\n    \"Efficient Data Structures\": [0.6, 0.7]\n    \"Parallel Processing\": [0.5, 0.6]\n    \"Memory Optimization\": [0.3, 0.4]\n    \"Error Handling\": [0.1, 0.2]\n    \"Our Target Product\": [0.8, 0.9]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to check for non-prime numbers."], ["P1", "Optimize the function for performance with large inputs."], ["P2", "Provide unit tests to ensure accuracy of the function."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python's built-in data structures and libraries to handle the array operations. We will calculate the mean of the array and then iterate through the array to find pairs of elements that, when removed, result in the same mean. This approach will be optimized to handle large inputs efficiently.", "File list": ["test.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,prd_Requirement Pool,design_Program call flow", "requirements": "No required packages", "code": "## main.py\nfrom typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    if mean * 2 != int(mean * 2):\n        return 0\n    \n    mean_int = int(mean * 2)\n    count = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if (total_sum - arr[i] - arr[j]) * 2 == mean_int * (n - 2):\n                count += 1\n    \n    return count\n\n# Interface using input() and print()\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to check for non-prime numbers."], ["P1", "Optimize the function for performance with large inputs."], ["P2", "Provide unit tests to ensure accuracy of the function."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python's built-in data structures and libraries. The main idea is to calculate the mean of the array and then iterate through all possible pairs of elements to check if removing them results in the same mean. We will use a dictionary to keep track of the counts of the differences between elements and the array sum, which helps in efficiently checking if removing two elements results in the desired mean.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,design_Program call flow,task_Full API spec", "requirements": "No required packages", "code": "from typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard library and the ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will use a brute-force method to ensure simplicity and correctness, and we will optimize it by using efficient data structures and avoiding redundant calculations.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": "Clarification needed on how to start and initialize third-party libraries."}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Requirement Pool,prd_UI Design draft,design_Program call flow", "requirements": "No required packages", "code": "from typing import List\n\ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                pairs += 1\n    return pairs\n\n# Read input and output results\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Performance and Scalability\"\n    x-axis \"Low Performance\" --> \"High Performance\"\n    y-axis \"Low Scalability\" --> \"High Scalability\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Brute Force Approach\": [0.2, 0.3]\n    \"Optimized Solution\": [0.7, 0.8]\n    \"Advanced Mathematical Techniques\": [0.4, 0.5]\n    \"Efficient Data Structures\": [0.6, 0.7]\n    \"Parallel Processing\": [0.5, 0.6]\n    \"Memory Optimization\": [0.3, 0.4]\n    \"Error Handling\": [0.1, 0.2]\n    \"Our Target Product\": [0.8, 0.9]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to check for non-prime numbers."], ["P1", "Optimize the function for performance with large inputs."], ["P2", "Provide unit tests to ensure accuracy of the function."]], "UI Design draft": "The function will be a simple command-line interface where users can input numbers and receive immediate feedback on their primality status.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard library and the ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will use a brute-force method initially to ensure correctness, and then optimize it for performance.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef count_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = count_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,design_Program call flow,task_Required packages", "requirements": "required packages are a,b,c,d,e,f,g", "code": "from typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard library and the ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will use a brute-force method to ensure simplicity and correctness, but we will optimize it by avoiding unnecessary calculations.", "File list": ["main.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["required packages are a,b,c,d,e,f,g"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
{"file_name": "codecontest_60_no_prd_Competitive Analysis,prd_Competitive Quadrant Chart,design_File list,design_Program call flow", "requirements": "No required packages", "code": "from typing import List\n\ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    total_sum = sum(arr)\n    mean = total_sum / n\n    \n    pairs_to_delete = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            new_sum = total_sum - arr[i] - arr[j]\n            new_mean = new_sum / (n - 2)\n            if new_mean == mean:\n                pairs_to_delete += 1\n    \n    return pairs_to_delete\n\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "prd": {"Language": "Python", "Programming Language": "Python", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n", "Project Name": "", "Product Goals": ["Create an efficient solution to calculate the number of pairs of positions to delete.", "Ensure the solution is scalable and can handle large inputs within the constraints.", "Optimize the algorithm to minimize computational time."], "User Stories": ["As a user, I want to quickly understand the task and provide the necessary input to get the result.", "As a user, I want the output to be accurate and match the expected result based on the input.", "As a user, I want the solution to be efficient so that it works quickly even for large arrays."], "Competitive Analysis": ["NumPy: Efficient numerical operations but lacks specific non-prime identification", "SymPy: Offers prime checking but is more complex than needed for simple tasks", "math.isprime: Simple prime checking but does not directly identify non-prime numbers", "Primality Test Libraries: Various libraries exist but may be overkill for basic needs", "Custom Implementations: Many users create their own functions but may lack optimization"], "Competitive Quadrant Chart": "quadrantChart\n    title \"Reach and engagement of campaigns\"\n    x-axis \"Low Reach\" --> \"High Reach\"\n    y-axis \"Low Engagement\" --> \"High Engagement\"\n    quadrant-1 \"We should expand\"\n    quadrant-2 \"Need to promote\"\n    quadrant-3 \"Re-evaluate\"\n    quadrant-4 \"May be improved\"\n    \"Library A\": [0.3, 0.6]\n    \"Library B\": [0.45, 0.23]\n    \"Library C\": [0.57, 0.69]\n    \"Library D\": [0.78, 0.34]\n    \"Library E\": [0.40, 0.34]\n    \"Our Target Function\": [0.5, 0.6]", "Requirement Analysis": "The problem requires calculating the mean of the array and then finding pairs of elements that, when removed, result in the same mean. This involves iterating through the array to check each possible pair of elements. The challenge lies in optimizing this process to handle large inputs efficiently.", "Requirement Pool": [["P0", "Implement a function to calculate the mean of the array."], ["P0", "Create a function to find pairs of elements that, when removed, result in the same mean."], ["P0", "Ensure the solution is optimized for large inputs."], ["P1", "Add error handling for invalid inputs."], ["P2", "Implement parallel processing to speed up the computation for large arrays."]], "UI Design draft": "A simple console interface with clear instructions for input and output.", "Anything UNCLEAR": ""}, "system_design": {"Implementation approach": "To solve this problem efficiently, we will use Python due to its powerful standard library and the ability to handle large datasets. The approach involves calculating the mean of the array and then iterating through the array to find pairs of elements that, when removed, result in the same mean. We will use a nested loop to check each possible pair of elements.", "File list": ["test.py"], "Data structures and interfaces": "\n# List the function signature, do not implement \ndef calculate_pairs_to_delete(n: int, arr: List[int]) -> int:\n    pass\n# Provide the Interface using input() and print(), DO NOT use stdin\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    result = calculate_pairs_to_delete(n, arr)\n    print(result)\n", "Program call flow": "sequenceDiagram\n    participant User\n    participant Function\n    User->>Function: Call is_non_prime(n)\n    Function-->>User: Return True if non-prime, False if prime\n    Note over Function: Check if n <= 1\n    alt n <= 1\n        Function-->>User: Return True\n    else\n        Note over Function: Loop from 2 to sqrt(n)\n        loop Check divisibility\n            Function-->>Function: Check if n % i == 0\n            alt Found divisor\n                Function-->>User: Return True\n            end\n        end\n        Function-->>User: Return False", "Original Requirements": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \n\nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i. e. sum divided by n). \n\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n - 2) elements is still equal to k. \n\nYour task is to calculate the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nInput \n\nThe first line contains a single integer t (1 ≤ t ≤ 10^4) — the number of testcases. \n\nThe first line of each testcase contains one integer n (3 ≤ n ≤ 2 ⋅ 10^5) — the number of elements in the array. \n\nThe second line contains a sequence of integers a_1, a_2, ..., a_n (0 ≤ a_i ≤ 10^{9}), where a_i is the i-th element of the array. \n\nThe sum of n over all testcases doesn't exceed 2 ⋅ 10^5. \n\nOutput \n\nPrint one integer — the number of pairs of positions [i, j] (i < j) such that if the elements on these positions are deleted, the mathematic mean of (n - 2) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a). \n\nExample \n\nInput \n\n4 \n4 \n8 8 8 8 \n3 \n50 20 10 \n5 \n1 4 7 3 5 \n7 \n1 2 3 4 5 6 7 \n\nOutput \n\n6 \n0 \n2 \n3 \n"}, "task": {"Required packages": ["No required packages"], "Required Other language third-party packages": ["No third-party dependencies required"], "Logic Analysis": [["main.py", "Contains one function with the same input/output format as user requirement"]], "File list": ["main.py"], "Full API spec": "", "Shared Knowledge": "", "Anything UNCLEAR": ""}, "eval_result": true}
